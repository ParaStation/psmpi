/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil ; -*- */
/*
 *  (C) 2010 by Argonne National Laboratory.
 *      See COPYRIGHT in top-level directory.
 */
/* automatically generated
 *   by:   ./maint/extractcvars
 *   at:   Wed Nov 21 11:33:20 2018
 *
 * DO NOT EDIT!!!
 */

#include "mpiimpl.h"

/* Actual storage for cvars */
#if defined MPID_PRINT_ERROR_STACK
int MPIR_CVAR_PRINT_ERROR_STACK = MPID_PRINT_ERROR_STACK;
#else
int MPIR_CVAR_PRINT_ERROR_STACK = 1;
#endif /* MPID_PRINT_ERROR_STACK */

#if defined MPID_CHOP_ERROR_STACK
int MPIR_CVAR_CHOP_ERROR_STACK = MPID_CHOP_ERROR_STACK;
#else
int MPIR_CVAR_CHOP_ERROR_STACK = 0;
#endif /* MPID_CHOP_ERROR_STACK */

int MPIR_CVAR_DIMS_VERBOSE = 0;
#if defined MPID_EXSCAN_INTRA_ALGORITHM
char * MPIR_CVAR_EXSCAN_INTRA_ALGORITHM = MPID_EXSCAN_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_EXSCAN_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_EXSCAN_INTRA_ALGORITHM */

#if defined MPID_EXSCAN_DEVICE_COLLECTIVE
int MPIR_CVAR_EXSCAN_DEVICE_COLLECTIVE = MPID_EXSCAN_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_EXSCAN_DEVICE_COLLECTIVE = 1;
#endif /* MPID_EXSCAN_DEVICE_COLLECTIVE */

#if defined MPID_IREDUCE_SCATTER_RECEXCH_KVAL
int MPIR_CVAR_IREDUCE_SCATTER_RECEXCH_KVAL = MPID_IREDUCE_SCATTER_RECEXCH_KVAL;
#else
int MPIR_CVAR_IREDUCE_SCATTER_RECEXCH_KVAL = 2;
#endif /* MPID_IREDUCE_SCATTER_RECEXCH_KVAL */

#if defined MPID_IREDUCE_SCATTER_INTRA_ALGORITHM
char * MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM = MPID_IREDUCE_SCATTER_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IREDUCE_SCATTER_INTRA_ALGORITHM */

#if defined MPID_IREDUCE_SCATTER_INTER_ALGORITHM
char * MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM = MPID_IREDUCE_SCATTER_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IREDUCE_SCATTER_INTER_ALGORITHM */

#if defined MPID_IREDUCE_SCATTER_DEVICE_COLLECTIVE
int MPIR_CVAR_IREDUCE_SCATTER_DEVICE_COLLECTIVE = MPID_IREDUCE_SCATTER_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IREDUCE_SCATTER_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IREDUCE_SCATTER_DEVICE_COLLECTIVE */

#if defined MPID_IALLTOALLW_INTRA_ALGORITHM
char * MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM = MPID_IALLTOALLW_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IALLTOALLW_INTRA_ALGORITHM */

#if defined MPID_IALLTOALLW_INTER_ALGORITHM
char * MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM = MPID_IALLTOALLW_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IALLTOALLW_INTER_ALGORITHM */

#if defined MPID_IALLTOALLW_DEVICE_COLLECTIVE
int MPIR_CVAR_IALLTOALLW_DEVICE_COLLECTIVE = MPID_IALLTOALLW_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IALLTOALLW_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IALLTOALLW_DEVICE_COLLECTIVE */

#if defined MPID_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM
char * MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM = MPID_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM */

#if defined MPID_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM
char * MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM = MPID_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM;
#else
char * MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM */

#if defined MPID_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE
int MPIR_CVAR_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE = MPID_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE = 1;
#endif /* MPID_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE */

#if defined MPID_IALLTOALLV_INTRA_ALGORITHM
char * MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM = MPID_IALLTOALLV_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IALLTOALLV_INTRA_ALGORITHM */

#if defined MPID_IALLTOALLV_INTER_ALGORITHM
char * MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM = MPID_IALLTOALLV_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IALLTOALLV_INTER_ALGORITHM */

#if defined MPID_IALLTOALLV_DEVICE_COLLECTIVE
int MPIR_CVAR_IALLTOALLV_DEVICE_COLLECTIVE = MPID_IALLTOALLV_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IALLTOALLV_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IALLTOALLV_DEVICE_COLLECTIVE */

#if defined MPID_ALLGATHERV_PIPELINE_MSG_SIZE
int MPIR_CVAR_ALLGATHERV_PIPELINE_MSG_SIZE = MPID_ALLGATHERV_PIPELINE_MSG_SIZE;
#else
int MPIR_CVAR_ALLGATHERV_PIPELINE_MSG_SIZE = 32768;
#endif /* MPID_ALLGATHERV_PIPELINE_MSG_SIZE */

#if defined MPID_ALLGATHERV_INTRA_ALGORITHM
char * MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM = MPID_ALLGATHERV_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_ALLGATHERV_INTRA_ALGORITHM */

#if defined MPID_ALLGATHERV_INTER_ALGORITHM
char * MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM = MPID_ALLGATHERV_INTER_ALGORITHM;
#else
char * MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_ALLGATHERV_INTER_ALGORITHM */

#if defined MPID_ALLGATHERV_DEVICE_COLLECTIVE
int MPIR_CVAR_ALLGATHERV_DEVICE_COLLECTIVE = MPID_ALLGATHERV_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_ALLGATHERV_DEVICE_COLLECTIVE = 1;
#endif /* MPID_ALLGATHERV_DEVICE_COLLECTIVE */

#if defined MPID_ALLREDUCE_SHORT_MSG_SIZE
int MPIR_CVAR_ALLREDUCE_SHORT_MSG_SIZE = MPID_ALLREDUCE_SHORT_MSG_SIZE;
#else
int MPIR_CVAR_ALLREDUCE_SHORT_MSG_SIZE = 2048;
#endif /* MPID_ALLREDUCE_SHORT_MSG_SIZE */

#if defined MPID_ENABLE_SMP_COLLECTIVES
int MPIR_CVAR_ENABLE_SMP_COLLECTIVES = MPID_ENABLE_SMP_COLLECTIVES;
#else
int MPIR_CVAR_ENABLE_SMP_COLLECTIVES = 1;
#endif /* MPID_ENABLE_SMP_COLLECTIVES */

#if defined MPID_ENABLE_SMP_ALLREDUCE
int MPIR_CVAR_ENABLE_SMP_ALLREDUCE = MPID_ENABLE_SMP_ALLREDUCE;
#else
int MPIR_CVAR_ENABLE_SMP_ALLREDUCE = 1;
#endif /* MPID_ENABLE_SMP_ALLREDUCE */

#if defined MPID_MAX_SMP_ALLREDUCE_MSG_SIZE
int MPIR_CVAR_MAX_SMP_ALLREDUCE_MSG_SIZE = MPID_MAX_SMP_ALLREDUCE_MSG_SIZE;
#else
int MPIR_CVAR_MAX_SMP_ALLREDUCE_MSG_SIZE = 0;
#endif /* MPID_MAX_SMP_ALLREDUCE_MSG_SIZE */

#if defined MPID_ALLREDUCE_INTRA_ALGORITHM
char * MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM = MPID_ALLREDUCE_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_ALLREDUCE_INTRA_ALGORITHM */

#if defined MPID_ALLREDUCE_INTER_ALGORITHM
char * MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM = MPID_ALLREDUCE_INTER_ALGORITHM;
#else
char * MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_ALLREDUCE_INTER_ALGORITHM */

#if defined MPID_ALLREDUCE_DEVICE_COLLECTIVE
int MPIR_CVAR_ALLREDUCE_DEVICE_COLLECTIVE = MPID_ALLREDUCE_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_ALLREDUCE_DEVICE_COLLECTIVE = 1;
#endif /* MPID_ALLREDUCE_DEVICE_COLLECTIVE */

#if defined MPID_IGATHER_INTRA_ALGORITHM
char * MPIR_CVAR_IGATHER_INTRA_ALGORITHM = MPID_IGATHER_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IGATHER_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IGATHER_INTRA_ALGORITHM */

#if defined MPID_IGATHER_TREE_KVAL
int MPIR_CVAR_IGATHER_TREE_KVAL = MPID_IGATHER_TREE_KVAL;
#else
int MPIR_CVAR_IGATHER_TREE_KVAL = 2;
#endif /* MPID_IGATHER_TREE_KVAL */

#if defined MPID_IGATHER_INTER_ALGORITHM
char * MPIR_CVAR_IGATHER_INTER_ALGORITHM = MPID_IGATHER_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IGATHER_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IGATHER_INTER_ALGORITHM */

#if defined MPID_IGATHER_DEVICE_COLLECTIVE
int MPIR_CVAR_IGATHER_DEVICE_COLLECTIVE = MPID_IGATHER_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IGATHER_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IGATHER_DEVICE_COLLECTIVE */

#if defined MPID_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM
char * MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM = MPID_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM */

#if defined MPID_NEIGHBOR_ALLTOALL_INTER_ALGORITHM
char * MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM = MPID_NEIGHBOR_ALLTOALL_INTER_ALGORITHM;
#else
char * MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_NEIGHBOR_ALLTOALL_INTER_ALGORITHM */

#if defined MPID_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE
int MPIR_CVAR_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE = MPID_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE = 1;
#endif /* MPID_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE */

#if defined MPID_IALLTOALL_INTRA_ALGORITHM
char * MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM = MPID_IALLTOALL_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IALLTOALL_INTRA_ALGORITHM */

#if defined MPID_IALLTOALL_INTER_ALGORITHM
char * MPIR_CVAR_IALLTOALL_INTER_ALGORITHM = MPID_IALLTOALL_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IALLTOALL_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IALLTOALL_INTER_ALGORITHM */

#if defined MPID_IALLTOALL_DEVICE_COLLECTIVE
int MPIR_CVAR_IALLTOALL_DEVICE_COLLECTIVE = MPID_IALLTOALL_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IALLTOALL_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IALLTOALL_DEVICE_COLLECTIVE */

#if defined MPID_SCATTER_INTER_SHORT_MSG_SIZE
int MPIR_CVAR_SCATTER_INTER_SHORT_MSG_SIZE = MPID_SCATTER_INTER_SHORT_MSG_SIZE;
#else
int MPIR_CVAR_SCATTER_INTER_SHORT_MSG_SIZE = 2048;
#endif /* MPID_SCATTER_INTER_SHORT_MSG_SIZE */

#if defined MPID_SCATTER_INTRA_ALGORITHM
char * MPIR_CVAR_SCATTER_INTRA_ALGORITHM = MPID_SCATTER_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_SCATTER_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_SCATTER_INTRA_ALGORITHM */

#if defined MPID_SCATTER_INTER_ALGORITHM
char * MPIR_CVAR_SCATTER_INTER_ALGORITHM = MPID_SCATTER_INTER_ALGORITHM;
#else
char * MPIR_CVAR_SCATTER_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_SCATTER_INTER_ALGORITHM */

#if defined MPID_SCATTER_DEVICE_COLLECTIVE
int MPIR_CVAR_SCATTER_DEVICE_COLLECTIVE = MPID_SCATTER_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_SCATTER_DEVICE_COLLECTIVE = 1;
#endif /* MPID_SCATTER_DEVICE_COLLECTIVE */

#if defined MPID_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM
char * MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM = MPID_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM */

#if defined MPID_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM
char * MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM = MPID_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM;
#else
char * MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM */

#if defined MPID_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE
int MPIR_CVAR_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE = MPID_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE = 1;
#endif /* MPID_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE */

#if defined MPID_IREDUCE_TREE_KVAL
int MPIR_CVAR_IREDUCE_TREE_KVAL = MPID_IREDUCE_TREE_KVAL;
#else
int MPIR_CVAR_IREDUCE_TREE_KVAL = 2;
#endif /* MPID_IREDUCE_TREE_KVAL */

#if defined MPID_IREDUCE_TREE_TYPE
char * MPIR_CVAR_IREDUCE_TREE_TYPE = MPID_IREDUCE_TREE_TYPE;
#else
char * MPIR_CVAR_IREDUCE_TREE_TYPE = (char*)"kary";
#endif /* MPID_IREDUCE_TREE_TYPE */

#if defined MPID_IREDUCE_TREE_PIPELINE_CHUNK_SIZE
int MPIR_CVAR_IREDUCE_TREE_PIPELINE_CHUNK_SIZE = MPID_IREDUCE_TREE_PIPELINE_CHUNK_SIZE;
#else
int MPIR_CVAR_IREDUCE_TREE_PIPELINE_CHUNK_SIZE = -1;
#endif /* MPID_IREDUCE_TREE_PIPELINE_CHUNK_SIZE */

#if defined MPID_IREDUCE_RING_CHUNK_SIZE
int MPIR_CVAR_IREDUCE_RING_CHUNK_SIZE = MPID_IREDUCE_RING_CHUNK_SIZE;
#else
int MPIR_CVAR_IREDUCE_RING_CHUNK_SIZE = 0;
#endif /* MPID_IREDUCE_RING_CHUNK_SIZE */

#if defined MPID_IREDUCE_TREE_BUFFER_PER_CHILD
int MPIR_CVAR_IREDUCE_TREE_BUFFER_PER_CHILD = MPID_IREDUCE_TREE_BUFFER_PER_CHILD;
#else
int MPIR_CVAR_IREDUCE_TREE_BUFFER_PER_CHILD = 0;
#endif /* MPID_IREDUCE_TREE_BUFFER_PER_CHILD */

#if defined MPID_IREDUCE_INTRA_ALGORITHM
char * MPIR_CVAR_IREDUCE_INTRA_ALGORITHM = MPID_IREDUCE_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IREDUCE_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IREDUCE_INTRA_ALGORITHM */

#if defined MPID_IREDUCE_INTER_ALGORITHM
char * MPIR_CVAR_IREDUCE_INTER_ALGORITHM = MPID_IREDUCE_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IREDUCE_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IREDUCE_INTER_ALGORITHM */

#if defined MPID_IREDUCE_DEVICE_COLLECTIVE
int MPIR_CVAR_IREDUCE_DEVICE_COLLECTIVE = MPID_IREDUCE_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IREDUCE_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IREDUCE_DEVICE_COLLECTIVE */

#if defined MPID_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM
char * MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM = MPID_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM */

#if defined MPID_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM
char * MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM = MPID_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM;
#else
char * MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM */

#if defined MPID_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE
int MPIR_CVAR_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE = MPID_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE = 1;
#endif /* MPID_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE */

#if defined MPID_GATHERV_INTER_SSEND_MIN_PROCS
int MPIR_CVAR_GATHERV_INTER_SSEND_MIN_PROCS = MPID_GATHERV_INTER_SSEND_MIN_PROCS;
#else
int MPIR_CVAR_GATHERV_INTER_SSEND_MIN_PROCS = 32;
#endif /* MPID_GATHERV_INTER_SSEND_MIN_PROCS */

#if defined MPID_GATHERV_INTRA_ALGORITHM
char * MPIR_CVAR_GATHERV_INTRA_ALGORITHM = MPID_GATHERV_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_GATHERV_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_GATHERV_INTRA_ALGORITHM */

#if defined MPID_GATHERV_INTER_ALGORITHM
char * MPIR_CVAR_GATHERV_INTER_ALGORITHM = MPID_GATHERV_INTER_ALGORITHM;
#else
char * MPIR_CVAR_GATHERV_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_GATHERV_INTER_ALGORITHM */

#if defined MPID_GATHERV_DEVICE_COLLECTIVE
int MPIR_CVAR_GATHERV_DEVICE_COLLECTIVE = MPID_GATHERV_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_GATHERV_DEVICE_COLLECTIVE = 1;
#endif /* MPID_GATHERV_DEVICE_COLLECTIVE */

#if defined MPID_ISCATTER_INTRA_ALGORITHM
char * MPIR_CVAR_ISCATTER_INTRA_ALGORITHM = MPID_ISCATTER_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_ISCATTER_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_ISCATTER_INTRA_ALGORITHM */

#if defined MPID_ISCATTER_TREE_KVAL
int MPIR_CVAR_ISCATTER_TREE_KVAL = MPID_ISCATTER_TREE_KVAL;
#else
int MPIR_CVAR_ISCATTER_TREE_KVAL = 2;
#endif /* MPID_ISCATTER_TREE_KVAL */

#if defined MPID_ISCATTER_INTER_ALGORITHM
char * MPIR_CVAR_ISCATTER_INTER_ALGORITHM = MPID_ISCATTER_INTER_ALGORITHM;
#else
char * MPIR_CVAR_ISCATTER_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_ISCATTER_INTER_ALGORITHM */

#if defined MPID_ISCATTER_DEVICE_COLLECTIVE
int MPIR_CVAR_ISCATTER_DEVICE_COLLECTIVE = MPID_ISCATTER_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_ISCATTER_DEVICE_COLLECTIVE = 1;
#endif /* MPID_ISCATTER_DEVICE_COLLECTIVE */

#if defined MPID_PROGRESS_MAX_COLLS
int MPIR_CVAR_PROGRESS_MAX_COLLS = MPID_PROGRESS_MAX_COLLS;
#else
int MPIR_CVAR_PROGRESS_MAX_COLLS = 8;
#endif /* MPID_PROGRESS_MAX_COLLS */

#if defined MPID_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM
char * MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM = MPID_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM */

#if defined MPID_NEIGHBOR_ALLGATHER_INTER_ALGORITHM
char * MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM = MPID_NEIGHBOR_ALLGATHER_INTER_ALGORITHM;
#else
char * MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_NEIGHBOR_ALLGATHER_INTER_ALGORITHM */

#if defined MPID_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE
int MPIR_CVAR_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE = MPID_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE = 1;
#endif /* MPID_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE */

#if defined MPID_ALLGATHER_SHORT_MSG_SIZE
int MPIR_CVAR_ALLGATHER_SHORT_MSG_SIZE = MPID_ALLGATHER_SHORT_MSG_SIZE;
#else
int MPIR_CVAR_ALLGATHER_SHORT_MSG_SIZE = 81920;
#endif /* MPID_ALLGATHER_SHORT_MSG_SIZE */

#if defined MPID_ALLGATHER_LONG_MSG_SIZE
int MPIR_CVAR_ALLGATHER_LONG_MSG_SIZE = MPID_ALLGATHER_LONG_MSG_SIZE;
#else
int MPIR_CVAR_ALLGATHER_LONG_MSG_SIZE = 524288;
#endif /* MPID_ALLGATHER_LONG_MSG_SIZE */

#if defined MPID_ALLGATHER_INTRA_ALGORITHM
char * MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM = MPID_ALLGATHER_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_ALLGATHER_INTRA_ALGORITHM */

#if defined MPID_ALLGATHER_INTER_ALGORITHM
char * MPIR_CVAR_ALLGATHER_INTER_ALGORITHM = MPID_ALLGATHER_INTER_ALGORITHM;
#else
char * MPIR_CVAR_ALLGATHER_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_ALLGATHER_INTER_ALGORITHM */

#if defined MPID_ALLGATHER_DEVICE_COLLECTIVE
int MPIR_CVAR_ALLGATHER_DEVICE_COLLECTIVE = MPID_ALLGATHER_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_ALLGATHER_DEVICE_COLLECTIVE = 1;
#endif /* MPID_ALLGATHER_DEVICE_COLLECTIVE */

#if defined MPID_ALLTOALLV_INTRA_ALGORITHM
char * MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM = MPID_ALLTOALLV_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_ALLTOALLV_INTRA_ALGORITHM */

#if defined MPID_ALLTOALLV_INTER_ALGORITHM
char * MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM = MPID_ALLTOALLV_INTER_ALGORITHM;
#else
char * MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_ALLTOALLV_INTER_ALGORITHM */

#if defined MPID_ALLTOALLV_DEVICE_COLLECTIVE
int MPIR_CVAR_ALLTOALLV_DEVICE_COLLECTIVE = MPID_ALLTOALLV_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_ALLTOALLV_DEVICE_COLLECTIVE = 1;
#endif /* MPID_ALLTOALLV_DEVICE_COLLECTIVE */

#if defined MPID_ALLTOALL_SHORT_MSG_SIZE
int MPIR_CVAR_ALLTOALL_SHORT_MSG_SIZE = MPID_ALLTOALL_SHORT_MSG_SIZE;
#else
int MPIR_CVAR_ALLTOALL_SHORT_MSG_SIZE = 256;
#endif /* MPID_ALLTOALL_SHORT_MSG_SIZE */

#if defined MPID_ALLTOALL_MEDIUM_MSG_SIZE
int MPIR_CVAR_ALLTOALL_MEDIUM_MSG_SIZE = MPID_ALLTOALL_MEDIUM_MSG_SIZE;
#else
int MPIR_CVAR_ALLTOALL_MEDIUM_MSG_SIZE = 32768;
#endif /* MPID_ALLTOALL_MEDIUM_MSG_SIZE */

#if defined MPID_ALLTOALL_THROTTLE
int MPIR_CVAR_ALLTOALL_THROTTLE = MPID_ALLTOALL_THROTTLE;
#else
int MPIR_CVAR_ALLTOALL_THROTTLE = 32;
#endif /* MPID_ALLTOALL_THROTTLE */

#if defined MPID_ALLTOALL_INTRA_ALGORITHM
char * MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM = MPID_ALLTOALL_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_ALLTOALL_INTRA_ALGORITHM */

#if defined MPID_ALLTOALL_INTER_ALGORITHM
char * MPIR_CVAR_ALLTOALL_INTER_ALGORITHM = MPID_ALLTOALL_INTER_ALGORITHM;
#else
char * MPIR_CVAR_ALLTOALL_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_ALLTOALL_INTER_ALGORITHM */

#if defined MPID_ALLTOALL_DEVICE_COLLECTIVE
int MPIR_CVAR_ALLTOALL_DEVICE_COLLECTIVE = MPID_ALLTOALL_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_ALLTOALL_DEVICE_COLLECTIVE = 1;
#endif /* MPID_ALLTOALL_DEVICE_COLLECTIVE */

#if defined MPID_IALLREDUCE_TREE_KVAL
int MPIR_CVAR_IALLREDUCE_TREE_KVAL = MPID_IALLREDUCE_TREE_KVAL;
#else
int MPIR_CVAR_IALLREDUCE_TREE_KVAL = 2;
#endif /* MPID_IALLREDUCE_TREE_KVAL */

#if defined MPID_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE
int MPIR_CVAR_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE = MPID_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE;
#else
int MPIR_CVAR_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE = -1;
#endif /* MPID_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE */

#if defined MPID_IALLREDUCE_TREE_BUFFER_PER_CHILD
int MPIR_CVAR_IALLREDUCE_TREE_BUFFER_PER_CHILD = MPID_IALLREDUCE_TREE_BUFFER_PER_CHILD;
#else
int MPIR_CVAR_IALLREDUCE_TREE_BUFFER_PER_CHILD = 0;
#endif /* MPID_IALLREDUCE_TREE_BUFFER_PER_CHILD */

#if defined MPID_IALLREDUCE_RECEXCH_KVAL
int MPIR_CVAR_IALLREDUCE_RECEXCH_KVAL = MPID_IALLREDUCE_RECEXCH_KVAL;
#else
int MPIR_CVAR_IALLREDUCE_RECEXCH_KVAL = 2;
#endif /* MPID_IALLREDUCE_RECEXCH_KVAL */

#if defined MPID_IALLREDUCE_INTRA_ALGORITHM
char * MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM = MPID_IALLREDUCE_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IALLREDUCE_INTRA_ALGORITHM */

#if defined MPID_IALLREDUCE_INTER_ALGORITHM
char * MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM = MPID_IALLREDUCE_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IALLREDUCE_INTER_ALGORITHM */

#if defined MPID_IALLREDUCE_DEVICE_COLLECTIVE
int MPIR_CVAR_IALLREDUCE_DEVICE_COLLECTIVE = MPID_IALLREDUCE_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IALLREDUCE_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IALLREDUCE_DEVICE_COLLECTIVE */

#if defined MPID_IEXSCAN_INTRA_ALGORITHM
char * MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM = MPID_IEXSCAN_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IEXSCAN_INTRA_ALGORITHM */

#if defined MPID_IEXSCAN_DEVICE_COLLECTIVE
int MPIR_CVAR_IEXSCAN_DEVICE_COLLECTIVE = MPID_IEXSCAN_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IEXSCAN_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IEXSCAN_DEVICE_COLLECTIVE */

#if defined MPID_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM
char * MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM = MPID_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM */

#if defined MPID_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM
char * MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM = MPID_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM;
#else
char * MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM */

#if defined MPID_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE
int MPIR_CVAR_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE = MPID_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE = 1;
#endif /* MPID_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE */

#if defined MPID_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE
int MPIR_CVAR_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE = MPID_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE;
#else
int MPIR_CVAR_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE = 524288;
#endif /* MPID_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE */

#if defined MPID_REDUCE_SCATTER_INTRA_ALGORITHM
char * MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM = MPID_REDUCE_SCATTER_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_REDUCE_SCATTER_INTRA_ALGORITHM */

#if defined MPID_REDUCE_SCATTER_INTER_ALGORITHM
char * MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM = MPID_REDUCE_SCATTER_INTER_ALGORITHM;
#else
char * MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_REDUCE_SCATTER_INTER_ALGORITHM */

#if defined MPID_REDUCE_SCATTER_DEVICE_COLLECTIVE
int MPIR_CVAR_REDUCE_SCATTER_DEVICE_COLLECTIVE = MPID_REDUCE_SCATTER_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_REDUCE_SCATTER_DEVICE_COLLECTIVE = 1;
#endif /* MPID_REDUCE_SCATTER_DEVICE_COLLECTIVE */

#if defined MPID_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM
char * MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM = MPID_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM */

#if defined MPID_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM
char * MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM = MPID_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM;
#else
char * MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM */

#if defined MPID_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE
int MPIR_CVAR_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE = MPID_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE = 1;
#endif /* MPID_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE */

#if defined MPID_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM
char * MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM = MPID_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM */

#if defined MPID_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM
char * MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM = MPID_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM;
#else
char * MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM */

#if defined MPID_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE
int MPIR_CVAR_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE = MPID_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE = 1;
#endif /* MPID_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE */

#if defined MPID_IBARRIER_RECEXCH_KVAL
int MPIR_CVAR_IBARRIER_RECEXCH_KVAL = MPID_IBARRIER_RECEXCH_KVAL;
#else
int MPIR_CVAR_IBARRIER_RECEXCH_KVAL = 2;
#endif /* MPID_IBARRIER_RECEXCH_KVAL */

#if defined MPID_IBARRIER_INTRA_ALGORITHM
char * MPIR_CVAR_IBARRIER_INTRA_ALGORITHM = MPID_IBARRIER_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IBARRIER_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IBARRIER_INTRA_ALGORITHM */

#if defined MPID_IBARRIER_INTER_ALGORITHM
char * MPIR_CVAR_IBARRIER_INTER_ALGORITHM = MPID_IBARRIER_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IBARRIER_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IBARRIER_INTER_ALGORITHM */

#if defined MPID_IBARRIER_DEVICE_COLLECTIVE
int MPIR_CVAR_IBARRIER_DEVICE_COLLECTIVE = MPID_IBARRIER_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IBARRIER_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IBARRIER_DEVICE_COLLECTIVE */

#if defined MPID_BCAST_MIN_PROCS
int MPIR_CVAR_BCAST_MIN_PROCS = MPID_BCAST_MIN_PROCS;
#else
int MPIR_CVAR_BCAST_MIN_PROCS = 8;
#endif /* MPID_BCAST_MIN_PROCS */

#if defined MPID_BCAST_SHORT_MSG_SIZE
int MPIR_CVAR_BCAST_SHORT_MSG_SIZE = MPID_BCAST_SHORT_MSG_SIZE;
#else
int MPIR_CVAR_BCAST_SHORT_MSG_SIZE = 12288;
#endif /* MPID_BCAST_SHORT_MSG_SIZE */

#if defined MPID_BCAST_LONG_MSG_SIZE
int MPIR_CVAR_BCAST_LONG_MSG_SIZE = MPID_BCAST_LONG_MSG_SIZE;
#else
int MPIR_CVAR_BCAST_LONG_MSG_SIZE = 524288;
#endif /* MPID_BCAST_LONG_MSG_SIZE */

#if defined MPID_ENABLE_SMP_BCAST
int MPIR_CVAR_ENABLE_SMP_BCAST = MPID_ENABLE_SMP_BCAST;
#else
int MPIR_CVAR_ENABLE_SMP_BCAST = 1;
#endif /* MPID_ENABLE_SMP_BCAST */

#if defined MPID_MAX_SMP_BCAST_MSG_SIZE
int MPIR_CVAR_MAX_SMP_BCAST_MSG_SIZE = MPID_MAX_SMP_BCAST_MSG_SIZE;
#else
int MPIR_CVAR_MAX_SMP_BCAST_MSG_SIZE = 0;
#endif /* MPID_MAX_SMP_BCAST_MSG_SIZE */

#if defined MPID_BCAST_INTRA_ALGORITHM
char * MPIR_CVAR_BCAST_INTRA_ALGORITHM = MPID_BCAST_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_BCAST_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_BCAST_INTRA_ALGORITHM */

#if defined MPID_BCAST_INTER_ALGORITHM
char * MPIR_CVAR_BCAST_INTER_ALGORITHM = MPID_BCAST_INTER_ALGORITHM;
#else
char * MPIR_CVAR_BCAST_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_BCAST_INTER_ALGORITHM */

#if defined MPID_BCAST_DEVICE_COLLECTIVE
int MPIR_CVAR_BCAST_DEVICE_COLLECTIVE = MPID_BCAST_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_BCAST_DEVICE_COLLECTIVE = 1;
#endif /* MPID_BCAST_DEVICE_COLLECTIVE */

#if defined MPID_IGATHERV_INTRA_ALGORITHM
char * MPIR_CVAR_IGATHERV_INTRA_ALGORITHM = MPID_IGATHERV_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IGATHERV_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IGATHERV_INTRA_ALGORITHM */

#if defined MPID_IGATHERV_INTER_ALGORITHM
char * MPIR_CVAR_IGATHERV_INTER_ALGORITHM = MPID_IGATHERV_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IGATHERV_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IGATHERV_INTER_ALGORITHM */

#if defined MPID_IGATHERV_DEVICE_COLLECTIVE
int MPIR_CVAR_IGATHERV_DEVICE_COLLECTIVE = MPID_IGATHERV_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IGATHERV_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IGATHERV_DEVICE_COLLECTIVE */

#if defined MPID_IALLGATHERV_RECEXCH_KVAL
int MPIR_CVAR_IALLGATHERV_RECEXCH_KVAL = MPID_IALLGATHERV_RECEXCH_KVAL;
#else
int MPIR_CVAR_IALLGATHERV_RECEXCH_KVAL = 2;
#endif /* MPID_IALLGATHERV_RECEXCH_KVAL */

#if defined MPID_IALLGATHERV_INTRA_ALGORITHM
char * MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM = MPID_IALLGATHERV_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IALLGATHERV_INTRA_ALGORITHM */

#if defined MPID_IALLGATHERV_INTER_ALGORITHM
char * MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM = MPID_IALLGATHERV_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IALLGATHERV_INTER_ALGORITHM */

#if defined MPID_IALLGATHERV_DEVICE_COLLECTIVE
int MPIR_CVAR_IALLGATHERV_DEVICE_COLLECTIVE = MPID_IALLGATHERV_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IALLGATHERV_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IALLGATHERV_DEVICE_COLLECTIVE */

#if defined MPID_ISCAN_INTRA_ALGORITHM
char * MPIR_CVAR_ISCAN_INTRA_ALGORITHM = MPID_ISCAN_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_ISCAN_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_ISCAN_INTRA_ALGORITHM */

#if defined MPID_ISCAN_DEVICE_COLLECTIVE
int MPIR_CVAR_ISCAN_DEVICE_COLLECTIVE = MPID_ISCAN_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_ISCAN_DEVICE_COLLECTIVE = 1;
#endif /* MPID_ISCAN_DEVICE_COLLECTIVE */

#if defined MPID_SCAN_INTRA_ALGORITHM
char * MPIR_CVAR_SCAN_INTRA_ALGORITHM = MPID_SCAN_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_SCAN_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_SCAN_INTRA_ALGORITHM */

#if defined MPID_SCAN_DEVICE_COLLECTIVE
int MPIR_CVAR_SCAN_DEVICE_COLLECTIVE = MPID_SCAN_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_SCAN_DEVICE_COLLECTIVE = 1;
#endif /* MPID_SCAN_DEVICE_COLLECTIVE */

#if defined MPID_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM
char * MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM = MPID_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM */

#if defined MPID_INEIGHBOR_ALLTOALL_INTER_ALGORITHM
char * MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM = MPID_INEIGHBOR_ALLTOALL_INTER_ALGORITHM;
#else
char * MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_INEIGHBOR_ALLTOALL_INTER_ALGORITHM */

#if defined MPID_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE
int MPIR_CVAR_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE = MPID_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE = 1;
#endif /* MPID_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE */

#if defined MPID_REDUCE_SHORT_MSG_SIZE
int MPIR_CVAR_REDUCE_SHORT_MSG_SIZE = MPID_REDUCE_SHORT_MSG_SIZE;
#else
int MPIR_CVAR_REDUCE_SHORT_MSG_SIZE = 2048;
#endif /* MPID_REDUCE_SHORT_MSG_SIZE */

#if defined MPID_ENABLE_SMP_REDUCE
int MPIR_CVAR_ENABLE_SMP_REDUCE = MPID_ENABLE_SMP_REDUCE;
#else
int MPIR_CVAR_ENABLE_SMP_REDUCE = 1;
#endif /* MPID_ENABLE_SMP_REDUCE */

#if defined MPID_MAX_SMP_REDUCE_MSG_SIZE
int MPIR_CVAR_MAX_SMP_REDUCE_MSG_SIZE = MPID_MAX_SMP_REDUCE_MSG_SIZE;
#else
int MPIR_CVAR_MAX_SMP_REDUCE_MSG_SIZE = 0;
#endif /* MPID_MAX_SMP_REDUCE_MSG_SIZE */

#if defined MPID_REDUCE_INTRA_ALGORITHM
char * MPIR_CVAR_REDUCE_INTRA_ALGORITHM = MPID_REDUCE_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_REDUCE_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_REDUCE_INTRA_ALGORITHM */

#if defined MPID_REDUCE_INTER_ALGORITHM
char * MPIR_CVAR_REDUCE_INTER_ALGORITHM = MPID_REDUCE_INTER_ALGORITHM;
#else
char * MPIR_CVAR_REDUCE_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_REDUCE_INTER_ALGORITHM */

#if defined MPID_REDUCE_DEVICE_COLLECTIVE
int MPIR_CVAR_REDUCE_DEVICE_COLLECTIVE = MPID_REDUCE_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_REDUCE_DEVICE_COLLECTIVE = 1;
#endif /* MPID_REDUCE_DEVICE_COLLECTIVE */

#if defined MPID_ALLTOALLW_INTRA_ALGORITHM
char * MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM = MPID_ALLTOALLW_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_ALLTOALLW_INTRA_ALGORITHM */

#if defined MPID_ALLTOALLW_INTER_ALGORITHM
char * MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM = MPID_ALLTOALLW_INTER_ALGORITHM;
#else
char * MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_ALLTOALLW_INTER_ALGORITHM */

#if defined MPID_ALLTOALLW_DEVICE_COLLECTIVE
int MPIR_CVAR_ALLTOALLW_DEVICE_COLLECTIVE = MPID_ALLTOALLW_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_ALLTOALLW_DEVICE_COLLECTIVE = 1;
#endif /* MPID_ALLTOALLW_DEVICE_COLLECTIVE */

#if defined MPID_ENABLE_SMP_BARRIER
int MPIR_CVAR_ENABLE_SMP_BARRIER = MPID_ENABLE_SMP_BARRIER;
#else
int MPIR_CVAR_ENABLE_SMP_BARRIER = 1;
#endif /* MPID_ENABLE_SMP_BARRIER */

#if defined MPID_BARRIER_INTRA_ALGORITHM
char * MPIR_CVAR_BARRIER_INTRA_ALGORITHM = MPID_BARRIER_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_BARRIER_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_BARRIER_INTRA_ALGORITHM */

#if defined MPID_BARRIER_INTER_ALGORITHM
char * MPIR_CVAR_BARRIER_INTER_ALGORITHM = MPID_BARRIER_INTER_ALGORITHM;
#else
char * MPIR_CVAR_BARRIER_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_BARRIER_INTER_ALGORITHM */

#if defined MPID_BARRIER_DEVICE_COLLECTIVE
int MPIR_CVAR_BARRIER_DEVICE_COLLECTIVE = MPID_BARRIER_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_BARRIER_DEVICE_COLLECTIVE = 1;
#endif /* MPID_BARRIER_DEVICE_COLLECTIVE */

#if defined MPID_ISCATTERV_INTRA_ALGORITHM
char * MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM = MPID_ISCATTERV_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_ISCATTERV_INTRA_ALGORITHM */

#if defined MPID_ISCATTERV_INTER_ALGORITHM
char * MPIR_CVAR_ISCATTERV_INTER_ALGORITHM = MPID_ISCATTERV_INTER_ALGORITHM;
#else
char * MPIR_CVAR_ISCATTERV_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_ISCATTERV_INTER_ALGORITHM */

#if defined MPID_ISCATTERV_DEVICE_COLLECTIVE
int MPIR_CVAR_ISCATTERV_DEVICE_COLLECTIVE = MPID_ISCATTERV_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_ISCATTERV_DEVICE_COLLECTIVE = 1;
#endif /* MPID_ISCATTERV_DEVICE_COLLECTIVE */

#if defined MPID_DEVICE_COLLECTIVES
int MPIR_CVAR_DEVICE_COLLECTIVES = MPID_DEVICE_COLLECTIVES;
#else
int MPIR_CVAR_DEVICE_COLLECTIVES = 1;
#endif /* MPID_DEVICE_COLLECTIVES */

#if defined MPID_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM
char * MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM = MPID_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM */

#if defined MPID_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM
char * MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM = MPID_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM;
#else
char * MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM */

#if defined MPID_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE
int MPIR_CVAR_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE = MPID_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE = 1;
#endif /* MPID_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE */

#if defined MPID_SCATTERV_INTRA_ALGORITHM
char * MPIR_CVAR_SCATTERV_INTRA_ALGORITHM = MPID_SCATTERV_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_SCATTERV_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_SCATTERV_INTRA_ALGORITHM */

#if defined MPID_SCATTERV_INTER_ALGORITHM
char * MPIR_CVAR_SCATTERV_INTER_ALGORITHM = MPID_SCATTERV_INTER_ALGORITHM;
#else
char * MPIR_CVAR_SCATTERV_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_SCATTERV_INTER_ALGORITHM */

#if defined MPID_SCATTERV_DEVICE_COLLECTIVE
int MPIR_CVAR_SCATTERV_DEVICE_COLLECTIVE = MPID_SCATTERV_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_SCATTERV_DEVICE_COLLECTIVE = 1;
#endif /* MPID_SCATTERV_DEVICE_COLLECTIVE */

#if defined MPID_GATHER_VSMALL_MSG_SIZE
int MPIR_CVAR_GATHER_VSMALL_MSG_SIZE = MPID_GATHER_VSMALL_MSG_SIZE;
#else
int MPIR_CVAR_GATHER_VSMALL_MSG_SIZE = 1024;
#endif /* MPID_GATHER_VSMALL_MSG_SIZE */

#if defined MPID_GATHER_INTER_SHORT_MSG_SIZE
int MPIR_CVAR_GATHER_INTER_SHORT_MSG_SIZE = MPID_GATHER_INTER_SHORT_MSG_SIZE;
#else
int MPIR_CVAR_GATHER_INTER_SHORT_MSG_SIZE = 2048;
#endif /* MPID_GATHER_INTER_SHORT_MSG_SIZE */

#if defined MPID_GATHER_INTRA_ALGORITHM
char * MPIR_CVAR_GATHER_INTRA_ALGORITHM = MPID_GATHER_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_GATHER_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_GATHER_INTRA_ALGORITHM */

#if defined MPID_GATHER_INTER_ALGORITHM
char * MPIR_CVAR_GATHER_INTER_ALGORITHM = MPID_GATHER_INTER_ALGORITHM;
#else
char * MPIR_CVAR_GATHER_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_GATHER_INTER_ALGORITHM */

#if defined MPID_GATHER_DEVICE_COLLECTIVE
int MPIR_CVAR_GATHER_DEVICE_COLLECTIVE = MPID_GATHER_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_GATHER_DEVICE_COLLECTIVE = 1;
#endif /* MPID_GATHER_DEVICE_COLLECTIVE */

#if defined MPID_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL
int MPIR_CVAR_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL = MPID_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL;
#else
int MPIR_CVAR_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL = 2;
#endif /* MPID_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL */

#if defined MPID_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM
char * MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM = MPID_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM */

#if defined MPID_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM
char * MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM = MPID_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM */

#if defined MPID_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE
int MPIR_CVAR_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE = MPID_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE */

#if defined MPID_IALLGATHER_RECEXCH_KVAL
int MPIR_CVAR_IALLGATHER_RECEXCH_KVAL = MPID_IALLGATHER_RECEXCH_KVAL;
#else
int MPIR_CVAR_IALLGATHER_RECEXCH_KVAL = 2;
#endif /* MPID_IALLGATHER_RECEXCH_KVAL */

#if defined MPID_IALLGATHER_BRUCKS_KVAL
int MPIR_CVAR_IALLGATHER_BRUCKS_KVAL = MPID_IALLGATHER_BRUCKS_KVAL;
#else
int MPIR_CVAR_IALLGATHER_BRUCKS_KVAL = 2;
#endif /* MPID_IALLGATHER_BRUCKS_KVAL */

#if defined MPID_IALLGATHER_INTRA_ALGORITHM
char * MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM = MPID_IALLGATHER_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IALLGATHER_INTRA_ALGORITHM */

#if defined MPID_IALLGATHER_INTER_ALGORITHM
char * MPIR_CVAR_IALLGATHER_INTER_ALGORITHM = MPID_IALLGATHER_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IALLGATHER_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IALLGATHER_INTER_ALGORITHM */

#if defined MPID_IALLGATHER_DEVICE_COLLECTIVE
int MPIR_CVAR_IALLGATHER_DEVICE_COLLECTIVE = MPID_IALLGATHER_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IALLGATHER_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IALLGATHER_DEVICE_COLLECTIVE */

#if defined MPID_IBCAST_TREE_KVAL
int MPIR_CVAR_IBCAST_TREE_KVAL = MPID_IBCAST_TREE_KVAL;
#else
int MPIR_CVAR_IBCAST_TREE_KVAL = 2;
#endif /* MPID_IBCAST_TREE_KVAL */

#if defined MPID_IBCAST_TREE_TYPE
char * MPIR_CVAR_IBCAST_TREE_TYPE = MPID_IBCAST_TREE_TYPE;
#else
char * MPIR_CVAR_IBCAST_TREE_TYPE = (char*)"kary";
#endif /* MPID_IBCAST_TREE_TYPE */

#if defined MPID_IBCAST_TREE_PIPELINE_CHUNK_SIZE
int MPIR_CVAR_IBCAST_TREE_PIPELINE_CHUNK_SIZE = MPID_IBCAST_TREE_PIPELINE_CHUNK_SIZE;
#else
int MPIR_CVAR_IBCAST_TREE_PIPELINE_CHUNK_SIZE = 0;
#endif /* MPID_IBCAST_TREE_PIPELINE_CHUNK_SIZE */

#if defined MPID_IBCAST_RING_CHUNK_SIZE
int MPIR_CVAR_IBCAST_RING_CHUNK_SIZE = MPID_IBCAST_RING_CHUNK_SIZE;
#else
int MPIR_CVAR_IBCAST_RING_CHUNK_SIZE = 0;
#endif /* MPID_IBCAST_RING_CHUNK_SIZE */

#if defined MPID_IBCAST_INTRA_ALGORITHM
char * MPIR_CVAR_IBCAST_INTRA_ALGORITHM = MPID_IBCAST_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_IBCAST_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_IBCAST_INTRA_ALGORITHM */

#if defined MPID_IBCAST_SCATTER_KVAL
int MPIR_CVAR_IBCAST_SCATTER_KVAL = MPID_IBCAST_SCATTER_KVAL;
#else
int MPIR_CVAR_IBCAST_SCATTER_KVAL = 2;
#endif /* MPID_IBCAST_SCATTER_KVAL */

#if defined MPID_IBCAST_ALLGATHER_RECEXCH_KVAL
int MPIR_CVAR_IBCAST_ALLGATHER_RECEXCH_KVAL = MPID_IBCAST_ALLGATHER_RECEXCH_KVAL;
#else
int MPIR_CVAR_IBCAST_ALLGATHER_RECEXCH_KVAL = 2;
#endif /* MPID_IBCAST_ALLGATHER_RECEXCH_KVAL */

#if defined MPID_IBCAST_INTER_ALGORITHM
char * MPIR_CVAR_IBCAST_INTER_ALGORITHM = MPID_IBCAST_INTER_ALGORITHM;
#else
char * MPIR_CVAR_IBCAST_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_IBCAST_INTER_ALGORITHM */

#if defined MPID_IBCAST_DEVICE_COLLECTIVE
int MPIR_CVAR_IBCAST_DEVICE_COLLECTIVE = MPID_IBCAST_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_IBCAST_DEVICE_COLLECTIVE = 1;
#endif /* MPID_IBCAST_DEVICE_COLLECTIVE */

#if defined MPID_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM
char * MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM = MPID_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM;
#else
char * MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM = (char*)"auto";
#endif /* MPID_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM */

#if defined MPID_INEIGHBOR_ALLGATHER_INTER_ALGORITHM
char * MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM = MPID_INEIGHBOR_ALLGATHER_INTER_ALGORITHM;
#else
char * MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM = (char*)"auto";
#endif /* MPID_INEIGHBOR_ALLGATHER_INTER_ALGORITHM */

#if defined MPID_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE
int MPIR_CVAR_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE = MPID_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE;
#else
int MPIR_CVAR_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE = 1;
#endif /* MPID_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE */

#if defined MPID_MEMDUMP
int MPIR_CVAR_MEMDUMP = MPID_MEMDUMP;
#else
int MPIR_CVAR_MEMDUMP = 1;
#endif /* MPID_MEMDUMP */

#if defined MPID_MEM_CATEGORY_INFORMATION
int MPIR_CVAR_MEM_CATEGORY_INFORMATION = MPID_MEM_CATEGORY_INFORMATION;
#else
int MPIR_CVAR_MEM_CATEGORY_INFORMATION = 0;
#endif /* MPID_MEM_CATEGORY_INFORMATION */

#if defined MPID_DEBUG_HOLD
int MPIR_CVAR_DEBUG_HOLD = MPID_DEBUG_HOLD;
#else
int MPIR_CVAR_DEBUG_HOLD = 0;
#endif /* MPID_DEBUG_HOLD */

#if defined MPID_ERROR_CHECKING
int MPIR_CVAR_ERROR_CHECKING = MPID_ERROR_CHECKING;
#else
int MPIR_CVAR_ERROR_CHECKING = 1;
#endif /* MPID_ERROR_CHECKING */

#if defined MPID_NETLOC_NODE_FILE
char * MPIR_CVAR_NETLOC_NODE_FILE = MPID_NETLOC_NODE_FILE;
#else
char * MPIR_CVAR_NETLOC_NODE_FILE = (char*)"auto";
#endif /* MPID_NETLOC_NODE_FILE */

#if defined MPID_SUPPRESS_ABORT_MESSAGE
int MPIR_CVAR_SUPPRESS_ABORT_MESSAGE = MPID_SUPPRESS_ABORT_MESSAGE;
#else
int MPIR_CVAR_SUPPRESS_ABORT_MESSAGE = 0;
#endif /* MPID_SUPPRESS_ABORT_MESSAGE */

#if defined MPID_ASYNC_PROGRESS
int MPIR_CVAR_ASYNC_PROGRESS = MPID_ASYNC_PROGRESS;
#else
int MPIR_CVAR_ASYNC_PROGRESS = 0;
#endif /* MPID_ASYNC_PROGRESS */

#if defined MPID_DEFAULT_THREAD_LEVEL
char * MPIR_CVAR_DEFAULT_THREAD_LEVEL = MPID_DEFAULT_THREAD_LEVEL;
#else
char * MPIR_CVAR_DEFAULT_THREAD_LEVEL = (char*)"MPI_THREAD_SINGLE";
#endif /* MPID_DEFAULT_THREAD_LEVEL */

#if defined MPID_COMM_SPLIT_USE_QSORT
int MPIR_CVAR_COMM_SPLIT_USE_QSORT = MPID_COMM_SPLIT_USE_QSORT;
#else
int MPIR_CVAR_COMM_SPLIT_USE_QSORT = 1;
#endif /* MPID_COMM_SPLIT_USE_QSORT */

#if defined MPID_CTXID_EAGER_SIZE
int MPIR_CVAR_CTXID_EAGER_SIZE = MPID_CTXID_EAGER_SIZE;
#else
int MPIR_CVAR_CTXID_EAGER_SIZE = 2;
#endif /* MPID_CTXID_EAGER_SIZE */

#if defined MPID_PROCTABLE_SIZE
int MPIR_CVAR_PROCTABLE_SIZE = MPID_PROCTABLE_SIZE;
#else
int MPIR_CVAR_PROCTABLE_SIZE = 64;
#endif /* MPID_PROCTABLE_SIZE */

#if defined MPID_PROCTABLE_PRINT
int MPIR_CVAR_PROCTABLE_PRINT = MPID_PROCTABLE_PRINT;
#else
int MPIR_CVAR_PROCTABLE_PRINT = 0;
#endif /* MPID_PROCTABLE_PRINT */

char * MPIR_CVAR_NAMESERV_FILE_PUBDIR = (char*)NULL;
#if defined MPID_ABORT_ON_LEAKED_HANDLES
int MPIR_CVAR_ABORT_ON_LEAKED_HANDLES = MPID_ABORT_ON_LEAKED_HANDLES;
#else
int MPIR_CVAR_ABORT_ON_LEAKED_HANDLES = 0;
#endif /* MPID_ABORT_ON_LEAKED_HANDLES */

int MPIR_CVAR_NOLOCAL = 0;
int MPIR_CVAR_ODD_EVEN_CLIQUES = 0;
int MPIR_CVAR_NUM_CLIQUES = 1;
#if defined MPID_REQUEST_POLL_FREQ
int MPIR_CVAR_REQUEST_POLL_FREQ = MPID_REQUEST_POLL_FREQ;
#else
int MPIR_CVAR_REQUEST_POLL_FREQ = 8;
#endif /* MPID_REQUEST_POLL_FREQ */

#if defined MPID_REQUEST_BATCH_SIZE
int MPIR_CVAR_REQUEST_BATCH_SIZE = MPID_REQUEST_BATCH_SIZE;
#else
int MPIR_CVAR_REQUEST_BATCH_SIZE = 64;
#endif /* MPID_REQUEST_BATCH_SIZE */

#if defined MPID_COLL_ALIAS_CHECK
int MPIR_CVAR_COLL_ALIAS_CHECK = MPID_COLL_ALIAS_CHECK;
#else
int MPIR_CVAR_COLL_ALIAS_CHECK = 1;
#endif /* MPID_COLL_ALIAS_CHECK */

#if defined MPID_CH4_OFI_CAPABILITY_SETS_DEBUG
int MPIR_CVAR_CH4_OFI_CAPABILITY_SETS_DEBUG = MPID_CH4_OFI_CAPABILITY_SETS_DEBUG;
#else
int MPIR_CVAR_CH4_OFI_CAPABILITY_SETS_DEBUG = 0;
#endif /* MPID_CH4_OFI_CAPABILITY_SETS_DEBUG */

#if defined MPID_CH4_OFI_ENABLE_DATA
int MPIR_CVAR_CH4_OFI_ENABLE_DATA = MPID_CH4_OFI_ENABLE_DATA;
#else
int MPIR_CVAR_CH4_OFI_ENABLE_DATA = -1;
#endif /* MPID_CH4_OFI_ENABLE_DATA */

#if defined MPID_CH4_OFI_ENABLE_AV_TABLE
int MPIR_CVAR_CH4_OFI_ENABLE_AV_TABLE = MPID_CH4_OFI_ENABLE_AV_TABLE;
#else
int MPIR_CVAR_CH4_OFI_ENABLE_AV_TABLE = -1;
#endif /* MPID_CH4_OFI_ENABLE_AV_TABLE */

#if defined MPID_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS
int MPIR_CVAR_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS = MPID_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS;
#else
int MPIR_CVAR_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS = -1;
#endif /* MPID_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS */

#if defined MPID_CH4_OFI_ENABLE_SHARED_CONTEXTS
int MPIR_CVAR_CH4_OFI_ENABLE_SHARED_CONTEXTS = MPID_CH4_OFI_ENABLE_SHARED_CONTEXTS;
#else
int MPIR_CVAR_CH4_OFI_ENABLE_SHARED_CONTEXTS = -1;
#endif /* MPID_CH4_OFI_ENABLE_SHARED_CONTEXTS */

#if defined MPID_CH4_OFI_ENABLE_MR_SCALABLE
int MPIR_CVAR_CH4_OFI_ENABLE_MR_SCALABLE = MPID_CH4_OFI_ENABLE_MR_SCALABLE;
#else
int MPIR_CVAR_CH4_OFI_ENABLE_MR_SCALABLE = -1;
#endif /* MPID_CH4_OFI_ENABLE_MR_SCALABLE */

#if defined MPID_CH4_OFI_ENABLE_TAGGED
int MPIR_CVAR_CH4_OFI_ENABLE_TAGGED = MPID_CH4_OFI_ENABLE_TAGGED;
#else
int MPIR_CVAR_CH4_OFI_ENABLE_TAGGED = -1;
#endif /* MPID_CH4_OFI_ENABLE_TAGGED */

#if defined MPID_CH4_OFI_ENABLE_AM
int MPIR_CVAR_CH4_OFI_ENABLE_AM = MPID_CH4_OFI_ENABLE_AM;
#else
int MPIR_CVAR_CH4_OFI_ENABLE_AM = -1;
#endif /* MPID_CH4_OFI_ENABLE_AM */

#if defined MPID_CH4_OFI_ENABLE_RMA
int MPIR_CVAR_CH4_OFI_ENABLE_RMA = MPID_CH4_OFI_ENABLE_RMA;
#else
int MPIR_CVAR_CH4_OFI_ENABLE_RMA = -1;
#endif /* MPID_CH4_OFI_ENABLE_RMA */

#if defined MPID_CH4_OFI_ENABLE_ATOMICS
int MPIR_CVAR_CH4_OFI_ENABLE_ATOMICS = MPID_CH4_OFI_ENABLE_ATOMICS;
#else
int MPIR_CVAR_CH4_OFI_ENABLE_ATOMICS = -1;
#endif /* MPID_CH4_OFI_ENABLE_ATOMICS */

#if defined MPID_CH4_OFI_FETCH_ATOMIC_IOVECS
int MPIR_CVAR_CH4_OFI_FETCH_ATOMIC_IOVECS = MPID_CH4_OFI_FETCH_ATOMIC_IOVECS;
#else
int MPIR_CVAR_CH4_OFI_FETCH_ATOMIC_IOVECS = -1;
#endif /* MPID_CH4_OFI_FETCH_ATOMIC_IOVECS */

#if defined MPID_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS
int MPIR_CVAR_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS = MPID_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS;
#else
int MPIR_CVAR_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS = -1;
#endif /* MPID_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS */

#if defined MPID_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS
int MPIR_CVAR_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS = MPID_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS;
#else
int MPIR_CVAR_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS = -1;
#endif /* MPID_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS */

#if defined MPID_CH4_OFI_ENABLE_PT2PT_NOPACK
int MPIR_CVAR_CH4_OFI_ENABLE_PT2PT_NOPACK = MPID_CH4_OFI_ENABLE_PT2PT_NOPACK;
#else
int MPIR_CVAR_CH4_OFI_ENABLE_PT2PT_NOPACK = -1;
#endif /* MPID_CH4_OFI_ENABLE_PT2PT_NOPACK */

#if defined MPID_CH4_OFI_CONTEXT_ID_BITS
int MPIR_CVAR_CH4_OFI_CONTEXT_ID_BITS = MPID_CH4_OFI_CONTEXT_ID_BITS;
#else
int MPIR_CVAR_CH4_OFI_CONTEXT_ID_BITS = -1;
#endif /* MPID_CH4_OFI_CONTEXT_ID_BITS */

#if defined MPID_CH4_OFI_RANK_BITS
int MPIR_CVAR_CH4_OFI_RANK_BITS = MPID_CH4_OFI_RANK_BITS;
#else
int MPIR_CVAR_CH4_OFI_RANK_BITS = -1;
#endif /* MPID_CH4_OFI_RANK_BITS */

#if defined MPID_CH4_OFI_TAG_BITS
int MPIR_CVAR_CH4_OFI_TAG_BITS = MPID_CH4_OFI_TAG_BITS;
#else
int MPIR_CVAR_CH4_OFI_TAG_BITS = -1;
#endif /* MPID_CH4_OFI_TAG_BITS */

#if defined MPID_CH4_OFI_MAJOR_VERSION
int MPIR_CVAR_CH4_OFI_MAJOR_VERSION = MPID_CH4_OFI_MAJOR_VERSION;
#else
int MPIR_CVAR_CH4_OFI_MAJOR_VERSION = -1;
#endif /* MPID_CH4_OFI_MAJOR_VERSION */

#if defined MPID_CH4_OFI_MINOR_VERSION
int MPIR_CVAR_CH4_OFI_MINOR_VERSION = MPID_CH4_OFI_MINOR_VERSION;
#else
int MPIR_CVAR_CH4_OFI_MINOR_VERSION = -1;
#endif /* MPID_CH4_OFI_MINOR_VERSION */

#if defined MPID_CH4_OFI_MAX_VNIS
int MPIR_CVAR_CH4_OFI_MAX_VNIS = MPID_CH4_OFI_MAX_VNIS;
#else
int MPIR_CVAR_CH4_OFI_MAX_VNIS = 1;
#endif /* MPID_CH4_OFI_MAX_VNIS */

#if defined MPID_CH4_OFI_MAX_RMA_SEP_CTX
int MPIR_CVAR_CH4_OFI_MAX_RMA_SEP_CTX = MPID_CH4_OFI_MAX_RMA_SEP_CTX;
#else
int MPIR_CVAR_CH4_OFI_MAX_RMA_SEP_CTX = 0;
#endif /* MPID_CH4_OFI_MAX_RMA_SEP_CTX */

#if defined MPID_CH4_OFI_MAX_EAGAIN_RETRY
int MPIR_CVAR_CH4_OFI_MAX_EAGAIN_RETRY = MPID_CH4_OFI_MAX_EAGAIN_RETRY;
#else
int MPIR_CVAR_CH4_OFI_MAX_EAGAIN_RETRY = -1;
#endif /* MPID_CH4_OFI_MAX_EAGAIN_RETRY */

#if defined MPID_CH4_OFI_NUM_AM_BUFFERS
int MPIR_CVAR_CH4_OFI_NUM_AM_BUFFERS = MPID_CH4_OFI_NUM_AM_BUFFERS;
#else
int MPIR_CVAR_CH4_OFI_NUM_AM_BUFFERS = -1;
#endif /* MPID_CH4_OFI_NUM_AM_BUFFERS */

int MPIR_CVAR_CH4_COMM_CONNECT_TIMEOUT = 180;
int MPIR_CVAR_CH4_RMA_MEM_EFFICIENT = 0;
#if defined MPID_CH4_NETMOD
char * MPIR_CVAR_CH4_NETMOD = MPID_CH4_NETMOD;
#else
char * MPIR_CVAR_CH4_NETMOD = (char*)"";
#endif /* MPID_CH4_NETMOD */

#if defined MPID_CH4_SHM
char * MPIR_CVAR_CH4_SHM = MPID_CH4_SHM;
#else
char * MPIR_CVAR_CH4_SHM = (char*)"";
#endif /* MPID_CH4_SHM */

#if defined MPID_CH4_ROOTS_ONLY_PMI
int MPIR_CVAR_CH4_ROOTS_ONLY_PMI = MPID_CH4_ROOTS_ONLY_PMI;
#else
int MPIR_CVAR_CH4_ROOTS_ONLY_PMI = 0;
#endif /* MPID_CH4_ROOTS_ONLY_PMI */

#if defined MPID_CH4_RUNTIME_CONF_DEBUG
int MPIR_CVAR_CH4_RUNTIME_CONF_DEBUG = MPID_CH4_RUNTIME_CONF_DEBUG;
#else
int MPIR_CVAR_CH4_RUNTIME_CONF_DEBUG = 0;
#endif /* MPID_CH4_RUNTIME_CONF_DEBUG */

#if defined MPID_CH4_MT_MODEL
char * MPIR_CVAR_CH4_MT_MODEL = MPID_CH4_MT_MODEL;
#else
char * MPIR_CVAR_CH4_MT_MODEL = (char*)"";
#endif /* MPID_CH4_MT_MODEL */

int MPIR_CVAR_CH4_RANDOM_ADDR_RETRY = 100;
int MPIR_CVAR_CH4_SHM_SYMHEAP_RETRY = 100;
#if defined MPID_ENABLE_HCOLL
int MPIR_CVAR_ENABLE_HCOLL = MPID_ENABLE_HCOLL;
#else
int MPIR_CVAR_ENABLE_HCOLL = 0;
#endif /* MPID_ENABLE_HCOLL */

#if defined MPID_COLL_SCHED_DUMP
int MPIR_CVAR_COLL_SCHED_DUMP = MPID_COLL_SCHED_DUMP;
#else
int MPIR_CVAR_COLL_SCHED_DUMP = 0;
#endif /* MPID_COLL_SCHED_DUMP */

#if defined MPID_OFI_USE_PROVIDER
char * MPIR_CVAR_OFI_USE_PROVIDER = MPID_OFI_USE_PROVIDER;
#else
char * MPIR_CVAR_OFI_USE_PROVIDER = (char*)NULL;
#endif /* MPID_OFI_USE_PROVIDER */

#if defined MPID_OFI_DUMP_PROVIDERS
int MPIR_CVAR_OFI_DUMP_PROVIDERS = MPID_OFI_DUMP_PROVIDERS;
#else
int MPIR_CVAR_OFI_DUMP_PROVIDERS = 0;
#endif /* MPID_OFI_DUMP_PROVIDERS */

int MPIR_CVAR_NEMESIS_MXM_BULK_CONNECT = 0;
int MPIR_CVAR_NEMESIS_MXM_BULK_DISCONNECT = 0;
int MPIR_CVAR_NEMESIS_MXM_HUGEPAGE = 0;
char * MPIR_CVAR_CH3_INTERFACE_HOSTNAME = (char*)NULL;
MPIR_T_cvar_range_value_t MPIR_CVAR_CH3_PORT_RANGE = {0,0};
char * MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE = (char*)NULL;
int MPIR_CVAR_NEMESIS_TCP_HOST_LOOKUP_RETRIES = 10;
int MPIR_CVAR_POLLS_BEFORE_YIELD = 1000;
char * MPIR_CVAR_NEMESIS_NETMOD = (char*)"";
int MPIR_CVAR_NEMESIS_SHM_EAGER_MAX_SZ = -1;
int MPIR_CVAR_NEMESIS_SHM_READY_EAGER_MAX_SZ = -2;
int MPIR_CVAR_NEMESIS_ENABLE_CKPOINT = 0;
int MPIR_CVAR_NEMESIS_LMT_DMA_THRESHOLD = 2097152;
#if defined MPID_ENABLE_FT
int MPIR_CVAR_ENABLE_FT = MPID_ENABLE_FT;
#else
int MPIR_CVAR_ENABLE_FT = 0;
#endif /* MPID_ENABLE_FT */

int MPIR_CVAR_CH3_RMA_SCALABLE_FENCE_PROCESS_NUM = 1024;
int MPIR_CVAR_CH3_RMA_DELAY_ISSUING_FOR_PIGGYBACKING = 0;
int MPIR_CVAR_CH3_EAGER_MAX_MSG_SIZE = 131072;
int MPIR_CVAR_CH3_RMA_SLOTS_SIZE = 262144;
int MPIR_CVAR_CH3_RMA_TARGET_LOCK_DATA_BYTES = 655360;
int MPIR_CVAR_CH3_RMA_OP_WIN_POOL_SIZE = 256;
int MPIR_CVAR_CH3_RMA_OP_GLOBAL_POOL_SIZE = 16384;
int MPIR_CVAR_CH3_RMA_TARGET_WIN_POOL_SIZE = 256;
int MPIR_CVAR_CH3_RMA_TARGET_GLOBAL_POOL_SIZE = 16384;
int MPIR_CVAR_CH3_RMA_TARGET_LOCK_ENTRY_WIN_POOL_SIZE = 256;
int MPIR_CVAR_CH3_RMA_ACTIVE_REQ_THRESHOLD = 65536;
int MPIR_CVAR_CH3_RMA_POKE_PROGRESS_REQ_THRESHOLD = 128;
int MPIR_CVAR_CH3_ENABLE_HCOLL = 0;
int MPIR_CVAR_CH3_COMM_CONNECT_TIMEOUT = 180;
int MPIR_CVAR_CH3_RMA_OP_PIGGYBACK_LOCK_DATA_SIZE = 65536;

#undef FUNCNAME
#define FUNCNAME MPIR_T_cvar_init
#undef FCNAME
#define FCNAME MPL_QUOTE(FUNCNAME)
int MPIR_T_cvar_init(void)
{
    int mpi_errno = MPI_SUCCESS;
    int rc;
    const char *tmp_str;
    static int initialized = FALSE;
    MPIR_T_cvar_value_t defaultval;

    /* FIXME any MT issues here? */
    if (initialized)
        return MPI_SUCCESS;
    initialized = TRUE;

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/mpi/errhan/errutil.c */
    MPIR_T_cat_add_desc("ERROR_HANDLING",
        "cvars that control error handling behavior (stack traces, aborts, etc)");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/mpi/topo/dims_create.c */
    MPIR_T_cat_add_desc("DIMS",
        "Dims_create cvars");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/mpi/coll/alltoall/alltoall.c */
    MPIR_T_cat_add_desc("COLLECTIVE",
        "A category for collective communication variables.");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/mpi/init/finalize.c */
    MPIR_T_cat_add_desc("DEVELOPER",
        "useful for developers working on MPICH itself");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/mpi/init/initthread.c */
    MPIR_T_cat_add_desc("DEBUGGER",
        "cvars relevant to the \"MPIR\" debugger interface");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/mpi/init/init.c */
    MPIR_T_cat_add_desc("THREADS",
        "multi-threading cvars");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/mpi/comm/comm_split.c */
    MPIR_T_cat_add_desc("COMMUNICATOR",
        "cvars that control communicator construction and operation");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/nameserv/file/file_nameserv.c */
    MPIR_T_cat_add_desc("PROCESS_MANAGER",
        "cvars that control the client-side process manager code");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/util/mem/handlemem.c */
    MPIR_T_cat_add_desc("MEMORY",
        "affects memory allocation and usage, including MPI object handles");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/util/nodemap/build_nodemap.h */
    MPIR_T_cat_add_desc("NODEMAP",
        "cvars that control behavior of nodemap");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/include/mpir_request.h */
    MPIR_T_cat_add_desc("REQUEST",
        "A category for requests mangement variables");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/mpid/ch4/netmod/ofi/ofi_init.h */
    MPIR_T_cat_add_desc("CH4_OFI",
        "A category for CH4 OFI netmod variables");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/mpid/ch4/src/ch4_init.h */
    MPIR_T_cat_add_desc("CH4",
        "cvars that control behavior of the CH4 device");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/mpid/ch3/channels/nemesis/src/mpid_nem_init.c */
    MPIR_T_cat_add_desc("NEMESIS",
        "cvars that control behavior of the ch3:nemesis channel");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/mpid/ch3/channels/nemesis/src/mpid_nem_lmt.c */
    MPIR_T_cat_add_desc("FT",
        "cvars that control behavior of fault tolerance");

    /* declared in /tmp/F8kHb7tPTK/mpich-3.3/maint/../src/mpid/ch3/src/mpidi_rma.c */
    MPIR_T_cat_add_desc("CH3",
        "cvars that control behavior of ch3");

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_PRINT_ERROR_STACK, /* name */
        &MPIR_CVAR_PRINT_ERROR_STACK, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "ERROR_HANDLING", /* category */
        "If true, print an error stack trace at error handling time.");
    rc = MPL_env2bool("MPICH_PRINT_ERROR_STACK", &(MPIR_CVAR_PRINT_ERROR_STACK));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_PRINT_ERROR_STACK");
    rc = MPL_env2bool("MPIR_PARAM_PRINT_ERROR_STACK", &(MPIR_CVAR_PRINT_ERROR_STACK));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_PRINT_ERROR_STACK");
    rc = MPL_env2bool("MPIR_CVAR_PRINT_ERROR_STACK", &(MPIR_CVAR_PRINT_ERROR_STACK));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_PRINT_ERROR_STACK");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CHOP_ERROR_STACK, /* name */
        &MPIR_CVAR_CHOP_ERROR_STACK, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "ERROR_HANDLING", /* category */
        "If >0, truncate error stack output lines this many characters wide.  If 0, do not truncate, and if <0 use a sensible default.");
    rc = MPL_env2int("MPICH_CHOP_ERROR_STACK", &(MPIR_CVAR_CHOP_ERROR_STACK));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CHOP_ERROR_STACK");
    rc = MPL_env2int("MPIR_PARAM_CHOP_ERROR_STACK", &(MPIR_CVAR_CHOP_ERROR_STACK));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CHOP_ERROR_STACK");
    rc = MPL_env2int("MPIR_CVAR_CHOP_ERROR_STACK", &(MPIR_CVAR_CHOP_ERROR_STACK));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CHOP_ERROR_STACK");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_DIMS_VERBOSE, /* name */
        &MPIR_CVAR_DIMS_VERBOSE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_MPIDEV_DETAIL,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "DIMS", /* category */
        "If true, enable verbose output about the actions of the implementation of MPI_Dims_create.");
    rc = MPL_env2bool("MPICH_DIMS_VERBOSE", &(MPIR_CVAR_DIMS_VERBOSE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_DIMS_VERBOSE");
    rc = MPL_env2bool("MPIR_PARAM_DIMS_VERBOSE", &(MPIR_CVAR_DIMS_VERBOSE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_DIMS_VERBOSE");
    rc = MPL_env2bool("MPIR_CVAR_DIMS_VERBOSE", &(MPIR_CVAR_DIMS_VERBOSE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_DIMS_VERBOSE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_EXSCAN_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_EXSCAN_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select allgather algorithm\
auto               - Internal algorithm selection\
nb                 - Force nonblocking algorithm\
recursive_doubling - Force recursive doubling algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_EXSCAN_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_EXSCAN_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_EXSCAN_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_EXSCAN_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_EXSCAN_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_EXSCAN_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_EXSCAN_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_EXSCAN_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_EXSCAN_INTRA_ALGORITHM);
        if (MPIR_CVAR_EXSCAN_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_EXSCAN_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_EXSCAN_INTRA_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_EXSCAN_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_EXSCAN_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Exscan will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level exscan function will not be called.");
    rc = MPL_env2bool("MPICH_EXSCAN_DEVICE_COLLECTIVE", &(MPIR_CVAR_EXSCAN_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_EXSCAN_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_EXSCAN_DEVICE_COLLECTIVE", &(MPIR_CVAR_EXSCAN_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_EXSCAN_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_EXSCAN_DEVICE_COLLECTIVE", &(MPIR_CVAR_EXSCAN_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_EXSCAN_DEVICE_COLLECTIVE");

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IREDUCE_SCATTER_RECEXCH_KVAL, /* name */
        &MPIR_CVAR_IREDUCE_SCATTER_RECEXCH_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for recursive exchange based ireduce_scatter");
    rc = MPL_env2int("MPICH_IREDUCE_SCATTER_RECEXCH_KVAL", &(MPIR_CVAR_IREDUCE_SCATTER_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_SCATTER_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IREDUCE_SCATTER_RECEXCH_KVAL", &(MPIR_CVAR_IREDUCE_SCATTER_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_SCATTER_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IREDUCE_SCATTER_RECEXCH_KVAL", &(MPIR_CVAR_IREDUCE_SCATTER_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_SCATTER_RECEXCH_KVAL");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ireduce_scatter algorithm\
auto               - Internal algorithm selection\
noncommutative     - Force noncommutative algorithm\
recursive_doubling - Force recursive doubling algorithm\
pairwise           - Force pairwise algorithm\
recursive_halving  - Force recursive halving algorithm\
recexch  - Force generic transport recursive exchange algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IREDUCE_SCATTER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_SCATTER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IREDUCE_SCATTER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_SCATTER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM);
        if (MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ireduce_scatter algorithm\
auto                         - Internal algorithm selection\
remote_reduce_local_scatterv - Force remote-reduce-local-scatterv algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IREDUCE_SCATTER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_SCATTER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IREDUCE_SCATTER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_SCATTER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM);
        if (MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IREDUCE_SCATTER_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IREDUCE_SCATTER_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Ireduce_scatter will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level ireduce_scatter function will not be called.");
    rc = MPL_env2bool("MPICH_IREDUCE_SCATTER_DEVICE_COLLECTIVE", &(MPIR_CVAR_IREDUCE_SCATTER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_SCATTER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IREDUCE_SCATTER_DEVICE_COLLECTIVE", &(MPIR_CVAR_IREDUCE_SCATTER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_SCATTER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IREDUCE_SCATTER_DEVICE_COLLECTIVE", &(MPIR_CVAR_IREDUCE_SCATTER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_SCATTER_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ialltoallw algorithm\
auto              - Internal algorithm selection\
blocked           - Force blocked algorithm\
inplace           - Force inplace algorithm\
pairwise_exchange - Force pairwise exchange algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IALLTOALLW_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLTOALLW_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IALLTOALLW_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLTOALLW_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM);
        if (MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ialltoallw algorithm\
auto - Internal algorithm selection");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IALLTOALLW_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLTOALLW_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IALLTOALLW_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLTOALLW_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM);
        if (MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLTOALLW_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IALLTOALLW_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Ialltoallw will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level ialltoallw function will not be called.");
    rc = MPL_env2bool("MPICH_IALLTOALLW_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLTOALLW_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLTOALLW_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IALLTOALLW_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLTOALLW_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLTOALLW_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IALLTOALLW_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLTOALLW_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLTOALLW_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select neighbor_alltoallw algorithm\
auto - Internal algorithm selection\
nb   - Force nb algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM);
        if (MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select neighbor_alltoallw algorithm\
auto - Internal algorithm selection\
nb   - Force nb algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM);
        if (MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_neighbor_alltoallw will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level neighbor_alltoallw function will not be called.");
    rc = MPL_env2bool("MPICH_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ialltoallv algorithm\
auto              - Internal algorithm selection\
blocked           - Force blocked algorithm\
inplace           - Force inplace algorithm\
pairwise_exchange - Force pairwise exchange algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IALLTOALLV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLTOALLV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IALLTOALLV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLTOALLV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM);
        if (MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ialltoallv algorithm\
auto - Internal algorithm selection");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IALLTOALLV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLTOALLV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IALLTOALLV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLTOALLV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM);
        if (MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLTOALLV_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IALLTOALLV_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Ialltoallv will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level ialltoallv function will not be called.");
    rc = MPL_env2bool("MPICH_IALLTOALLV_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLTOALLV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLTOALLV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IALLTOALLV_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLTOALLV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLTOALLV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IALLTOALLV_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLTOALLV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLTOALLV_DEVICE_COLLECTIVE");

    defaultval.d = 32768;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLGATHERV_PIPELINE_MSG_SIZE, /* name */
        &MPIR_CVAR_ALLGATHERV_PIPELINE_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "The smallest message size that will be used for the pipelined, large-message, ring algorithm in the MPI_Allgatherv implementation.");
    rc = MPL_env2int("MPICH_ALLGATHERV_PIPELINE_MSG_SIZE", &(MPIR_CVAR_ALLGATHERV_PIPELINE_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLGATHERV_PIPELINE_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_ALLGATHERV_PIPELINE_MSG_SIZE", &(MPIR_CVAR_ALLGATHERV_PIPELINE_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLGATHERV_PIPELINE_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_ALLGATHERV_PIPELINE_MSG_SIZE", &(MPIR_CVAR_ALLGATHERV_PIPELINE_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLGATHERV_PIPELINE_MSG_SIZE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select allgatherv algorithm\
auto               - Internal algorithm selection\
brucks             - Force brucks algorithm\
nb                 - Force nonblocking algorithm\
recursive_doubling - Force recursive doubling algorithm\
ring               - Force ring algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ALLGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLGATHERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ALLGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLGATHERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM);
        if (MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select allgatherv algorithm\
auto                      - Internal algorithm selection\
nb                        - Force nonblocking algorithm\
remote_gather_local_bcast - Force remote-gather-local-bcast algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ALLGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLGATHERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ALLGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLGATHERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM);
        if (MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLGATHERV_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_ALLGATHERV_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Allgatherv will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level allgatherv function will not be called.");
    rc = MPL_env2bool("MPICH_ALLGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLGATHERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_ALLGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLGATHERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_ALLGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLGATHERV_DEVICE_COLLECTIVE");

    defaultval.d = 2048;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLREDUCE_SHORT_MSG_SIZE, /* name */
        &MPIR_CVAR_ALLREDUCE_SHORT_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "the short message algorithm will be used if the send buffer size is <= this value (in bytes)");
    rc = MPL_env2int("MPICH_ALLREDUCE_SHORT_MSG_SIZE", &(MPIR_CVAR_ALLREDUCE_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLREDUCE_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_ALLREDUCE_SHORT_MSG_SIZE", &(MPIR_CVAR_ALLREDUCE_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLREDUCE_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_ALLREDUCE_SHORT_MSG_SIZE", &(MPIR_CVAR_ALLREDUCE_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLREDUCE_SHORT_MSG_SIZE");

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ENABLE_SMP_COLLECTIVES, /* name */
        &MPIR_CVAR_ENABLE_SMP_COLLECTIVES, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Enable SMP aware collective communication.");
    rc = MPL_env2bool("MPICH_ENABLE_SMP_COLLECTIVES", &(MPIR_CVAR_ENABLE_SMP_COLLECTIVES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ENABLE_SMP_COLLECTIVES");
    rc = MPL_env2bool("MPIR_PARAM_ENABLE_SMP_COLLECTIVES", &(MPIR_CVAR_ENABLE_SMP_COLLECTIVES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ENABLE_SMP_COLLECTIVES");
    rc = MPL_env2bool("MPIR_CVAR_ENABLE_SMP_COLLECTIVES", &(MPIR_CVAR_ENABLE_SMP_COLLECTIVES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ENABLE_SMP_COLLECTIVES");

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ENABLE_SMP_ALLREDUCE, /* name */
        &MPIR_CVAR_ENABLE_SMP_ALLREDUCE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Enable SMP aware allreduce.");
    rc = MPL_env2bool("MPICH_ENABLE_SMP_ALLREDUCE", &(MPIR_CVAR_ENABLE_SMP_ALLREDUCE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ENABLE_SMP_ALLREDUCE");
    rc = MPL_env2bool("MPIR_PARAM_ENABLE_SMP_ALLREDUCE", &(MPIR_CVAR_ENABLE_SMP_ALLREDUCE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ENABLE_SMP_ALLREDUCE");
    rc = MPL_env2bool("MPIR_CVAR_ENABLE_SMP_ALLREDUCE", &(MPIR_CVAR_ENABLE_SMP_ALLREDUCE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ENABLE_SMP_ALLREDUCE");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_MAX_SMP_ALLREDUCE_MSG_SIZE, /* name */
        &MPIR_CVAR_MAX_SMP_ALLREDUCE_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Maximum message size for which SMP-aware allreduce is used.  A value of '0' uses SMP-aware allreduce for all message sizes.");
    rc = MPL_env2int("MPICH_MAX_SMP_ALLREDUCE_MSG_SIZE", &(MPIR_CVAR_MAX_SMP_ALLREDUCE_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_MAX_SMP_ALLREDUCE_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_MAX_SMP_ALLREDUCE_MSG_SIZE", &(MPIR_CVAR_MAX_SMP_ALLREDUCE_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_MAX_SMP_ALLREDUCE_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_MAX_SMP_ALLREDUCE_MSG_SIZE", &(MPIR_CVAR_MAX_SMP_ALLREDUCE_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_MAX_SMP_ALLREDUCE_MSG_SIZE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select allreduce algorithm\
auto                     - Internal algorithm selection\
nb                       - Force nonblocking algorithm\
recursive_doubling       - Force recursive doubling algorithm\
reduce_scatter_allgather - Force reduce scatter allgather algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ALLREDUCE_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLREDUCE_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ALLREDUCE_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLREDUCE_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM);
        if (MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select allreduce algorithm\
auto                  - Internal algorithm selection\
nb                    - Force nonblocking algorithm\
reduce_exchange_bcast - Force reduce-exchange-bcast algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ALLREDUCE_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLREDUCE_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ALLREDUCE_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLREDUCE_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM);
        if (MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLREDUCE_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_ALLREDUCE_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Allreduce will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level allreduce function will not be called.");
    rc = MPL_env2bool("MPICH_ALLREDUCE_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLREDUCE_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLREDUCE_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_ALLREDUCE_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLREDUCE_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLREDUCE_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_ALLREDUCE_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLREDUCE_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLREDUCE_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IGATHER_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IGATHER_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select igather algorithm\
auto     - Internal algorithm selection\
binomial - Force binomial algorithm\
tree     - Force genetric transport based tree algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IGATHER_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IGATHER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IGATHER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IGATHER_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IGATHER_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IGATHER_INTRA_ALGORITHM);
        if (MPIR_CVAR_IGATHER_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IGATHER_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IGATHER_INTRA_ALGORITHM = NULL;
    }

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IGATHER_TREE_KVAL, /* name */
        &MPIR_CVAR_IGATHER_TREE_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for tree based igather");
    rc = MPL_env2int("MPICH_IGATHER_TREE_KVAL", &(MPIR_CVAR_IGATHER_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IGATHER_TREE_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IGATHER_TREE_KVAL", &(MPIR_CVAR_IGATHER_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IGATHER_TREE_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IGATHER_TREE_KVAL", &(MPIR_CVAR_IGATHER_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IGATHER_TREE_KVAL");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IGATHER_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IGATHER_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select igather algorithm\
auto        - Internal algorithm selection\
long_inter  - Force long inter algorithm\
short_inter - Force short inter algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IGATHER_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IGATHER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IGATHER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IGATHER_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IGATHER_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IGATHER_INTER_ALGORITHM);
        if (MPIR_CVAR_IGATHER_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IGATHER_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IGATHER_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IGATHER_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IGATHER_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Igather will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level igather function will not be called.");
    rc = MPL_env2bool("MPICH_IGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_IGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IGATHER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_IGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IGATHER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_IGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IGATHER_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select neighbor_alltoall algorithm\
auto - Internal algorithm selection\
nb   - Force nb algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM);
        if (MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select neighbor_alltoall algorithm\
auto - Internal algorithm selection\
nb   - Force nb algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_NEIGHBOR_ALLTOALL_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLTOALL_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_NEIGHBOR_ALLTOALL_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLTOALL_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM);
        if (MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_neighbor_alltoall will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level neighbor_alltoall function will not be called.");
    rc = MPL_env2bool("MPICH_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ialltoall algorithm\
auto              - Internal algorithm selection\
brucks            - Force brucks algorithm\
inplace           - Force inplace algorithm\
pairwise          - Force pairwise algorithm\
permuted_sendrecv - Force permuted sendrecv algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IALLTOALL_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLTOALL_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IALLTOALL_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLTOALL_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM);
        if (MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IALLTOALL_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IALLTOALL_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ialltoall algorithm\
auto              - Internal algorithm selection\
pairwise_exchange - Force pairwise exchange algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IALLTOALL_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IALLTOALL_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLTOALL_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IALLTOALL_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLTOALL_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IALLTOALL_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLTOALL_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IALLTOALL_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IALLTOALL_INTER_ALGORITHM);
        if (MPIR_CVAR_IALLTOALL_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IALLTOALL_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IALLTOALL_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLTOALL_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IALLTOALL_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Ialltoall will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level ialltoall function will not be called.");
    rc = MPL_env2bool("MPICH_IALLTOALL_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLTOALL_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLTOALL_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IALLTOALL_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLTOALL_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLTOALL_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IALLTOALL_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLTOALL_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLTOALL_DEVICE_COLLECTIVE");

    defaultval.d = 2048;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_SCATTER_INTER_SHORT_MSG_SIZE, /* name */
        &MPIR_CVAR_SCATTER_INTER_SHORT_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "use the short message algorithm for intercommunicator MPI_Scatter if the send buffer size is < this value (in bytes)");
    rc = MPL_env2int("MPICH_SCATTER_INTER_SHORT_MSG_SIZE", &(MPIR_CVAR_SCATTER_INTER_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_SCATTER_INTER_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_SCATTER_INTER_SHORT_MSG_SIZE", &(MPIR_CVAR_SCATTER_INTER_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_SCATTER_INTER_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_SCATTER_INTER_SHORT_MSG_SIZE", &(MPIR_CVAR_SCATTER_INTER_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_SCATTER_INTER_SHORT_MSG_SIZE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_SCATTER_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_SCATTER_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select scatter algorithm\
auto     - Internal algorithm selection\
binomial - Force binomial algorithm\
nb       - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_SCATTER_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_SCATTER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_SCATTER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_SCATTER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_SCATTER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_SCATTER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_SCATTER_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_SCATTER_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_SCATTER_INTRA_ALGORITHM);
        if (MPIR_CVAR_SCATTER_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_SCATTER_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_SCATTER_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_SCATTER_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_SCATTER_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select scatter algorithm\
auto                      - Internal algorithm selection\
linear                    - Force linear algorithm\
nb                        - Force nonblocking algorithm\
remote_send_local_scatter - Force remote-send-local-scatter algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_SCATTER_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_SCATTER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_SCATTER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_SCATTER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_SCATTER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_SCATTER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_SCATTER_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_SCATTER_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_SCATTER_INTER_ALGORITHM);
        if (MPIR_CVAR_SCATTER_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_SCATTER_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_SCATTER_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_SCATTER_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_SCATTER_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Scatter will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level scatter function will not be called.");
    rc = MPL_env2bool("MPICH_SCATTER_DEVICE_COLLECTIVE", &(MPIR_CVAR_SCATTER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_SCATTER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_SCATTER_DEVICE_COLLECTIVE", &(MPIR_CVAR_SCATTER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_SCATTER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_SCATTER_DEVICE_COLLECTIVE", &(MPIR_CVAR_SCATTER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_SCATTER_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select neighbor_allgatherv algorithm\
auto - Internal algorithm selection\
nb   - Force nb algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM);
        if (MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select neighbor_allgatherv algorithm\
auto - Internal algorithm selection\
nb   - Force nb algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM);
        if (MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_neighbor_allgatherv will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level neighbor_allgatherv function will not be called.");
    rc = MPL_env2bool("MPICH_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE");

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IREDUCE_TREE_KVAL, /* name */
        &MPIR_CVAR_IREDUCE_TREE_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for tree (kary, knomial, etc.) based ireduce");
    rc = MPL_env2int("MPICH_IREDUCE_TREE_KVAL", &(MPIR_CVAR_IREDUCE_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_TREE_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IREDUCE_TREE_KVAL", &(MPIR_CVAR_IREDUCE_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_TREE_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IREDUCE_TREE_KVAL", &(MPIR_CVAR_IREDUCE_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_TREE_KVAL");

    defaultval.str = (char *)"kary";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IREDUCE_TREE_TYPE, /* name */
        &MPIR_CVAR_IREDUCE_TREE_TYPE, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Tree type for tree based ireduce kary      - kary tree knomial_1 - knomial_1 tree knomial_2 - knomial_2 tree");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IREDUCE_TREE_TYPE, &tmp_str);
    rc = MPL_env2str("MPICH_IREDUCE_TREE_TYPE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_TREE_TYPE");
    rc = MPL_env2str("MPIR_PARAM_IREDUCE_TREE_TYPE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_TREE_TYPE");
    rc = MPL_env2str("MPIR_CVAR_IREDUCE_TREE_TYPE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_TREE_TYPE");
    if (tmp_str != NULL) {
        MPIR_CVAR_IREDUCE_TREE_TYPE = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IREDUCE_TREE_TYPE);
        if (MPIR_CVAR_IREDUCE_TREE_TYPE == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IREDUCE_TREE_TYPE");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IREDUCE_TREE_TYPE = NULL;
    }

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IREDUCE_TREE_PIPELINE_CHUNK_SIZE, /* name */
        &MPIR_CVAR_IREDUCE_TREE_PIPELINE_CHUNK_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Maximum chunk size (in bytes) for pipelining in tree based ireduce. Default value is 0, that is, no pipelining by default");
    rc = MPL_env2int("MPICH_IREDUCE_TREE_PIPELINE_CHUNK_SIZE", &(MPIR_CVAR_IREDUCE_TREE_PIPELINE_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_TREE_PIPELINE_CHUNK_SIZE");
    rc = MPL_env2int("MPIR_PARAM_IREDUCE_TREE_PIPELINE_CHUNK_SIZE", &(MPIR_CVAR_IREDUCE_TREE_PIPELINE_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_TREE_PIPELINE_CHUNK_SIZE");
    rc = MPL_env2int("MPIR_CVAR_IREDUCE_TREE_PIPELINE_CHUNK_SIZE", &(MPIR_CVAR_IREDUCE_TREE_PIPELINE_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_TREE_PIPELINE_CHUNK_SIZE");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IREDUCE_RING_CHUNK_SIZE, /* name */
        &MPIR_CVAR_IREDUCE_RING_CHUNK_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Maximum chunk size (in bytes) for pipelining in ireduce ring algorithm. Default value is 0, that is, no pipelining by default");
    rc = MPL_env2int("MPICH_IREDUCE_RING_CHUNK_SIZE", &(MPIR_CVAR_IREDUCE_RING_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_RING_CHUNK_SIZE");
    rc = MPL_env2int("MPIR_PARAM_IREDUCE_RING_CHUNK_SIZE", &(MPIR_CVAR_IREDUCE_RING_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_RING_CHUNK_SIZE");
    rc = MPL_env2int("MPIR_CVAR_IREDUCE_RING_CHUNK_SIZE", &(MPIR_CVAR_IREDUCE_RING_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_RING_CHUNK_SIZE");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IREDUCE_TREE_BUFFER_PER_CHILD, /* name */
        &MPIR_CVAR_IREDUCE_TREE_BUFFER_PER_CHILD, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, a rank in tree algorithms will allocate a dedicated buffer for every child it receives data from. This would mean more memory consumption but it would allow preposting of the receives and hence reduce the number of unexpected messages. If set to false, there is only one buffer that is used to receive the data from all the children. The receives are therefore serialized, that is, only one receive can be posted at a time.");
    rc = MPL_env2bool("MPICH_IREDUCE_TREE_BUFFER_PER_CHILD", &(MPIR_CVAR_IREDUCE_TREE_BUFFER_PER_CHILD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_TREE_BUFFER_PER_CHILD");
    rc = MPL_env2bool("MPIR_PARAM_IREDUCE_TREE_BUFFER_PER_CHILD", &(MPIR_CVAR_IREDUCE_TREE_BUFFER_PER_CHILD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_TREE_BUFFER_PER_CHILD");
    rc = MPL_env2bool("MPIR_CVAR_IREDUCE_TREE_BUFFER_PER_CHILD", &(MPIR_CVAR_IREDUCE_TREE_BUFFER_PER_CHILD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_TREE_BUFFER_PER_CHILD");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IREDUCE_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IREDUCE_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ireduce algorithm\
auto                  - Internal algorithm selection\
binomial              - Force binomial algorithm\
reduce_scatter_gather - Force reduce scatter gather algorithm\
tree                  - Force Generic Transport Tree\
ring                  - Force Generic Transport Ring");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IREDUCE_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IREDUCE_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IREDUCE_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IREDUCE_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IREDUCE_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IREDUCE_INTRA_ALGORITHM);
        if (MPIR_CVAR_IREDUCE_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IREDUCE_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IREDUCE_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IREDUCE_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IREDUCE_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ireduce algorithm\
auto                     - Internal algorithm selection\
local_reduce_remote_send - Force local-reduce-remote-send algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IREDUCE_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IREDUCE_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IREDUCE_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IREDUCE_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IREDUCE_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IREDUCE_INTER_ALGORITHM);
        if (MPIR_CVAR_IREDUCE_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IREDUCE_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IREDUCE_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IREDUCE_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IREDUCE_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Ireduce will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level ireduce function will not be called.");
    rc = MPL_env2bool("MPICH_IREDUCE_DEVICE_COLLECTIVE", &(MPIR_CVAR_IREDUCE_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IREDUCE_DEVICE_COLLECTIVE", &(MPIR_CVAR_IREDUCE_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IREDUCE_DEVICE_COLLECTIVE", &(MPIR_CVAR_IREDUCE_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select reduce_scatter_block algorithm\
auto               - Internal algorithm selection\
noncommutative     - Force noncommutative algorithm\
recursive_doubling - Force recursive doubling algorithm\
pairwise           - Force pairwise algorithm\
recursive_halving  - Force recursive halving algorithm\
nb                 - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM);
        if (MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select reduce_scatter_block algorithm\
auto                        - Internal algorithm selection\
nb                          - Force nonblocking algorithm\
remote_reduce_local_scatter - Force remote-reduce-local-scatter algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM);
        if (MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Reduce_scatter_block will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level reduce_scatter_block function will not be called.");
    rc = MPL_env2bool("MPICH_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE", &(MPIR_CVAR_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE", &(MPIR_CVAR_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE", &(MPIR_CVAR_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE");

    defaultval.d = 32;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_GATHERV_INTER_SSEND_MIN_PROCS, /* name */
        &MPIR_CVAR_GATHERV_INTER_SSEND_MIN_PROCS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Use Ssend (synchronous send) for intercommunicator MPI_Gatherv if the \"group B\" size is >= this value.  Specifying \"-1\" always avoids using Ssend.  For backwards compatibility, specifying \"0\" uses the default value.");
    rc = MPL_env2int("MPICH_GATHERV_INTER_SSEND_MIN_PROCS", &(MPIR_CVAR_GATHERV_INTER_SSEND_MIN_PROCS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_GATHERV_INTER_SSEND_MIN_PROCS");
    rc = MPL_env2int("MPIR_PARAM_GATHERV_INTER_SSEND_MIN_PROCS", &(MPIR_CVAR_GATHERV_INTER_SSEND_MIN_PROCS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_GATHERV_INTER_SSEND_MIN_PROCS");
    rc = MPL_env2int("MPIR_CVAR_GATHERV_INTER_SSEND_MIN_PROCS", &(MPIR_CVAR_GATHERV_INTER_SSEND_MIN_PROCS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_GATHERV_INTER_SSEND_MIN_PROCS");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_GATHERV_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_GATHERV_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select gatherv algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm\
nb     - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_GATHERV_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_GATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_GATHERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_GATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_GATHERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_GATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_GATHERV_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_GATHERV_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_GATHERV_INTRA_ALGORITHM);
        if (MPIR_CVAR_GATHERV_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_GATHERV_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_GATHERV_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_GATHERV_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_GATHERV_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select gatherv algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm\
nb     - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_GATHERV_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_GATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_GATHERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_GATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_GATHERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_GATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_GATHERV_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_GATHERV_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_GATHERV_INTER_ALGORITHM);
        if (MPIR_CVAR_GATHERV_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_GATHERV_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_GATHERV_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_GATHERV_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_GATHERV_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Gatherv will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level gatherv function will not be called.");
    rc = MPL_env2bool("MPICH_GATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_GATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_GATHERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_GATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_GATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_GATHERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_GATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_GATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_GATHERV_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ISCATTER_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_ISCATTER_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select iscatter algorithm\
auto     - Internal algorithm selection\
binomial - Force binomial algorithm\
tree     - Force genetric transport based tree algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ISCATTER_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ISCATTER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ISCATTER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ISCATTER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ISCATTER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ISCATTER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ISCATTER_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ISCATTER_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ISCATTER_INTRA_ALGORITHM);
        if (MPIR_CVAR_ISCATTER_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ISCATTER_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ISCATTER_INTRA_ALGORITHM = NULL;
    }

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ISCATTER_TREE_KVAL, /* name */
        &MPIR_CVAR_ISCATTER_TREE_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for tree based iscatter");
    rc = MPL_env2int("MPICH_ISCATTER_TREE_KVAL", &(MPIR_CVAR_ISCATTER_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ISCATTER_TREE_KVAL");
    rc = MPL_env2int("MPIR_PARAM_ISCATTER_TREE_KVAL", &(MPIR_CVAR_ISCATTER_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ISCATTER_TREE_KVAL");
    rc = MPL_env2int("MPIR_CVAR_ISCATTER_TREE_KVAL", &(MPIR_CVAR_ISCATTER_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ISCATTER_TREE_KVAL");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ISCATTER_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_ISCATTER_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select iscatter algorithm\
auto                      - Internal algorithm selection\
linear                    - Force linear algorithm\
remote_send_local_scatter - Force remote-send-local-scatter algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ISCATTER_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ISCATTER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ISCATTER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ISCATTER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ISCATTER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ISCATTER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ISCATTER_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ISCATTER_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ISCATTER_INTER_ALGORITHM);
        if (MPIR_CVAR_ISCATTER_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ISCATTER_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ISCATTER_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ISCATTER_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_ISCATTER_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Iscatter will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level iscatter function will not be called.");
    rc = MPL_env2bool("MPICH_ISCATTER_DEVICE_COLLECTIVE", &(MPIR_CVAR_ISCATTER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ISCATTER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_ISCATTER_DEVICE_COLLECTIVE", &(MPIR_CVAR_ISCATTER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ISCATTER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_ISCATTER_DEVICE_COLLECTIVE", &(MPIR_CVAR_ISCATTER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ISCATTER_DEVICE_COLLECTIVE");

    defaultval.d = 8;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_PROGRESS_MAX_COLLS, /* name */
        &MPIR_CVAR_PROGRESS_MAX_COLLS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Maximum number of collective operations at a time that the progress engine should make progress on");
    rc = MPL_env2int("MPICH_PROGRESS_MAX_COLLS", &(MPIR_CVAR_PROGRESS_MAX_COLLS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_PROGRESS_MAX_COLLS");
    rc = MPL_env2int("MPIR_PARAM_PROGRESS_MAX_COLLS", &(MPIR_CVAR_PROGRESS_MAX_COLLS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_PROGRESS_MAX_COLLS");
    rc = MPL_env2int("MPIR_CVAR_PROGRESS_MAX_COLLS", &(MPIR_CVAR_PROGRESS_MAX_COLLS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_PROGRESS_MAX_COLLS");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ineighbor_allgather algorithm\
auto - Internal algorithm selection\
nb   - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM);
        if (MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ineighbor_allgather algorithm\
auto - Internal algorithm selection\
nb   - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_NEIGHBOR_ALLGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLGATHER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_NEIGHBOR_ALLGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLGATHER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM);
        if (MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_neighbor_allgather will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level neighbor_allgather function will not be called.");
    rc = MPL_env2bool("MPICH_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE");

    defaultval.d = 81920;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLGATHER_SHORT_MSG_SIZE, /* name */
        &MPIR_CVAR_ALLGATHER_SHORT_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "For MPI_Allgather and MPI_Allgatherv, the short message algorithm will be used if the send buffer size is < this value (in bytes). (See also: MPIR_CVAR_ALLGATHER_LONG_MSG_SIZE)");
    rc = MPL_env2int("MPICH_ALLGATHER_SHORT_MSG_SIZE", &(MPIR_CVAR_ALLGATHER_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLGATHER_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_ALLGATHER_SHORT_MSG_SIZE", &(MPIR_CVAR_ALLGATHER_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLGATHER_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_ALLGATHER_SHORT_MSG_SIZE", &(MPIR_CVAR_ALLGATHER_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLGATHER_SHORT_MSG_SIZE");

    defaultval.d = 524288;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLGATHER_LONG_MSG_SIZE, /* name */
        &MPIR_CVAR_ALLGATHER_LONG_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "For MPI_Allgather and MPI_Allgatherv, the long message algorithm will be used if the send buffer size is >= this value (in bytes) (See also: MPIR_CVAR_ALLGATHER_SHORT_MSG_SIZE)");
    rc = MPL_env2int("MPICH_ALLGATHER_LONG_MSG_SIZE", &(MPIR_CVAR_ALLGATHER_LONG_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLGATHER_LONG_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_ALLGATHER_LONG_MSG_SIZE", &(MPIR_CVAR_ALLGATHER_LONG_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLGATHER_LONG_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_ALLGATHER_LONG_MSG_SIZE", &(MPIR_CVAR_ALLGATHER_LONG_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLGATHER_LONG_MSG_SIZE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select allgather algorithm\
auto               - Internal algorithm selection\
brucks             - Force brucks algorithm\
nb                 - Force nonblocking algorithm\
recursive_doubling - Force recursive doubling algorithm\
ring               - Force ring algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ALLGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLGATHER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ALLGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLGATHER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM);
        if (MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ALLGATHER_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_ALLGATHER_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select allgather algorithm\
auto                      - Internal algorithm selection\
local_gather_remote_bcast - Force local-gather-remote-bcast algorithm\
nb                        - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ALLGATHER_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ALLGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLGATHER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ALLGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLGATHER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ALLGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLGATHER_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ALLGATHER_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ALLGATHER_INTER_ALGORITHM);
        if (MPIR_CVAR_ALLGATHER_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ALLGATHER_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ALLGATHER_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLGATHER_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_ALLGATHER_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Allgather will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level allgather function will not be called.");
    rc = MPL_env2bool("MPICH_ALLGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLGATHER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_ALLGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLGATHER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_ALLGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLGATHER_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select alltoallv algorithm\
auto                      - Internal algorithm selection\
nb                        - Force nonblocking algorithm\
pairwise_sendrecv_replace - Force pairwise_sendrecv_replace algorithm\
scattered                 - Force scattered algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ALLTOALLV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLTOALLV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ALLTOALLV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLTOALLV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM);
        if (MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select alltoallv algorithm\
auto              - Internal algorithm selection\
pairwise_exchange - Force pairwise exchange algorithm\
nb                - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ALLTOALLV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLTOALLV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ALLTOALLV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLTOALLV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM);
        if (MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLTOALLV_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_ALLTOALLV_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Alltoallv will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level alltoallv function will not be called.");
    rc = MPL_env2bool("MPICH_ALLTOALLV_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLTOALLV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLTOALLV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_ALLTOALLV_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLTOALLV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLTOALLV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_ALLTOALLV_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLTOALLV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLTOALLV_DEVICE_COLLECTIVE");

    defaultval.d = 256;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLTOALL_SHORT_MSG_SIZE, /* name */
        &MPIR_CVAR_ALLTOALL_SHORT_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "the short message algorithm will be used if the per-destination message size (sendcount*size(sendtype)) is <= this value (See also: MPIR_CVAR_ALLTOALL_MEDIUM_MSG_SIZE)");
    rc = MPL_env2int("MPICH_ALLTOALL_SHORT_MSG_SIZE", &(MPIR_CVAR_ALLTOALL_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLTOALL_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_ALLTOALL_SHORT_MSG_SIZE", &(MPIR_CVAR_ALLTOALL_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLTOALL_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_ALLTOALL_SHORT_MSG_SIZE", &(MPIR_CVAR_ALLTOALL_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLTOALL_SHORT_MSG_SIZE");

    defaultval.d = 32768;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLTOALL_MEDIUM_MSG_SIZE, /* name */
        &MPIR_CVAR_ALLTOALL_MEDIUM_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "the medium message algorithm will be used if the per-destination message size (sendcount*size(sendtype)) is <= this value and larger than MPIR_CVAR_ALLTOALL_SHORT_MSG_SIZE (See also: MPIR_CVAR_ALLTOALL_SHORT_MSG_SIZE)");
    rc = MPL_env2int("MPICH_ALLTOALL_MEDIUM_MSG_SIZE", &(MPIR_CVAR_ALLTOALL_MEDIUM_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLTOALL_MEDIUM_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_ALLTOALL_MEDIUM_MSG_SIZE", &(MPIR_CVAR_ALLTOALL_MEDIUM_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLTOALL_MEDIUM_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_ALLTOALL_MEDIUM_MSG_SIZE", &(MPIR_CVAR_ALLTOALL_MEDIUM_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLTOALL_MEDIUM_MSG_SIZE");

    defaultval.d = 32;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLTOALL_THROTTLE, /* name */
        &MPIR_CVAR_ALLTOALL_THROTTLE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "max no. of irecvs/isends posted at a time in some alltoall algorithms. Setting it to 0 causes all irecvs/isends to be posted at once");
    rc = MPL_env2int("MPICH_ALLTOALL_THROTTLE", &(MPIR_CVAR_ALLTOALL_THROTTLE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLTOALL_THROTTLE");
    rc = MPL_env2int("MPIR_PARAM_ALLTOALL_THROTTLE", &(MPIR_CVAR_ALLTOALL_THROTTLE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLTOALL_THROTTLE");
    rc = MPL_env2int("MPIR_CVAR_ALLTOALL_THROTTLE", &(MPIR_CVAR_ALLTOALL_THROTTLE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLTOALL_THROTTLE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select alltoall algorithm\
auto                      - Internal algorithm selection\
brucks                    - Force brucks algorithm\
nb                        - Force nonblocking algorithm\
pairwise                  - Force pairwise algorithm\
pairwise_sendrecv_replace - Force pairwise sendrecv replace algorithm\
scattered                 - Force scattered algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ALLTOALL_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLTOALL_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ALLTOALL_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLTOALL_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM);
        if (MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ALLTOALL_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_ALLTOALL_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select alltoall algorithm\
auto              - Internal algorithm selection\
nb                - Force nonblocking algorithm\
pairwise_exchange - Force pairwise exchange algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ALLTOALL_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ALLTOALL_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLTOALL_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ALLTOALL_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLTOALL_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ALLTOALL_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLTOALL_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ALLTOALL_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ALLTOALL_INTER_ALGORITHM);
        if (MPIR_CVAR_ALLTOALL_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ALLTOALL_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ALLTOALL_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLTOALL_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_ALLTOALL_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Alltoall will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level alltoall function will not be called.");
    rc = MPL_env2bool("MPICH_ALLTOALL_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLTOALL_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLTOALL_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_ALLTOALL_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLTOALL_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLTOALL_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_ALLTOALL_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLTOALL_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLTOALL_DEVICE_COLLECTIVE");

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLREDUCE_TREE_KVAL, /* name */
        &MPIR_CVAR_IALLREDUCE_TREE_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for tree based iallreduce (for tree_kary and tree_knomial)");
    rc = MPL_env2int("MPICH_IALLREDUCE_TREE_KVAL", &(MPIR_CVAR_IALLREDUCE_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLREDUCE_TREE_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IALLREDUCE_TREE_KVAL", &(MPIR_CVAR_IALLREDUCE_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLREDUCE_TREE_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IALLREDUCE_TREE_KVAL", &(MPIR_CVAR_IALLREDUCE_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLREDUCE_TREE_KVAL");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE, /* name */
        &MPIR_CVAR_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Maximum chunk size (in bytes) for pipelining in tree based iallreduce (tree_kary and tree_knomial). Default value is 0, that is, no pipelining by default");
    rc = MPL_env2int("MPICH_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE", &(MPIR_CVAR_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE");
    rc = MPL_env2int("MPIR_PARAM_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE", &(MPIR_CVAR_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE");
    rc = MPL_env2int("MPIR_CVAR_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE", &(MPIR_CVAR_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLREDUCE_TREE_PIPELINE_CHUNK_SIZE");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLREDUCE_TREE_BUFFER_PER_CHILD, /* name */
        &MPIR_CVAR_IALLREDUCE_TREE_BUFFER_PER_CHILD, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, a rank in tree_kary and tree_knomial algorithms will allocate a dedicated buffer for every child it receives data from. This would mean more memory consumption but it would allow preposting of the receives and hence reduce the number of unexpected messages. If set to false, there is only one buffer that is used to receive the data from all the children. The receives are therefore serialized, that is, only one receive can be posted at a time.");
    rc = MPL_env2bool("MPICH_IALLREDUCE_TREE_BUFFER_PER_CHILD", &(MPIR_CVAR_IALLREDUCE_TREE_BUFFER_PER_CHILD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLREDUCE_TREE_BUFFER_PER_CHILD");
    rc = MPL_env2bool("MPIR_PARAM_IALLREDUCE_TREE_BUFFER_PER_CHILD", &(MPIR_CVAR_IALLREDUCE_TREE_BUFFER_PER_CHILD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLREDUCE_TREE_BUFFER_PER_CHILD");
    rc = MPL_env2bool("MPIR_CVAR_IALLREDUCE_TREE_BUFFER_PER_CHILD", &(MPIR_CVAR_IALLREDUCE_TREE_BUFFER_PER_CHILD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLREDUCE_TREE_BUFFER_PER_CHILD");

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLREDUCE_RECEXCH_KVAL, /* name */
        &MPIR_CVAR_IALLREDUCE_RECEXCH_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for recursive exchange based iallreduce");
    rc = MPL_env2int("MPICH_IALLREDUCE_RECEXCH_KVAL", &(MPIR_CVAR_IALLREDUCE_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLREDUCE_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IALLREDUCE_RECEXCH_KVAL", &(MPIR_CVAR_IALLREDUCE_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLREDUCE_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IALLREDUCE_RECEXCH_KVAL", &(MPIR_CVAR_IALLREDUCE_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLREDUCE_RECEXCH_KVAL");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select iallreduce algorithm\
auto                     - Internal algorithm selection\
naive                    - Force naive algorithm\
recursive_doubling       - Force recursive doubling algorithm\
reduce_scatter_allgather - Force reduce scatter allgather algorithm\
recexch_single_buffer    - Force generic transport recursive exchange with single buffer for receives\
recexch_multiple_buffer  - Force generic transport recursive exchange with multiple buffers for receives");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IALLREDUCE_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLREDUCE_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IALLREDUCE_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLREDUCE_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM);
        if (MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select iallreduce algorithm\
auto                      - Internal algorithm selection\
remote_reduce_local_bcast - Force remote-reduce-local-bcast algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IALLREDUCE_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLREDUCE_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IALLREDUCE_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLREDUCE_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM);
        if (MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLREDUCE_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IALLREDUCE_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Iallreduce will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level iallreduce function will not be called.");
    rc = MPL_env2bool("MPICH_IALLREDUCE_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLREDUCE_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLREDUCE_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IALLREDUCE_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLREDUCE_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLREDUCE_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IALLREDUCE_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLREDUCE_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLREDUCE_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select iexscan algorithm\
auto               - Internal algorithm selection\
recursive_doubling - Force recursive doubling algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IEXSCAN_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IEXSCAN_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IEXSCAN_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IEXSCAN_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM);
        if (MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IEXSCAN_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IEXSCAN_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Iexscan will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level iexscan function will not be called.");
    rc = MPL_env2bool("MPICH_IEXSCAN_DEVICE_COLLECTIVE", &(MPIR_CVAR_IEXSCAN_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IEXSCAN_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IEXSCAN_DEVICE_COLLECTIVE", &(MPIR_CVAR_IEXSCAN_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IEXSCAN_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IEXSCAN_DEVICE_COLLECTIVE", &(MPIR_CVAR_IEXSCAN_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IEXSCAN_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ineighbor_alltoallw algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM);
        if (MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ineighbor_alltoallw algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM);
        if (MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_ineighbor_alltoallw will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level ineighbor_alltoallw function will not be called.");
    rc = MPL_env2bool("MPICH_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLTOALLW_DEVICE_COLLECTIVE");

    defaultval.d = 524288;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE, /* name */
        &MPIR_CVAR_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "the long message algorithm will be used if the operation is commutative and the send buffer size is >= this value (in bytes)");
    rc = MPL_env2int("MPICH_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE", &(MPIR_CVAR_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE", &(MPIR_CVAR_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE", &(MPIR_CVAR_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REDUCE_SCATTER_COMMUTATIVE_LONG_MSG_SIZE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select reduce_scatter algorithm\
auto               - Internal algorithm selection\
nb                 - Force nonblocking algorithm\
noncommutative     - Force noncommutative algorithm\
pairwise           - Force pairwise algorithm\
recursive_doubling - Force recursive doubling algorithm\
recursive_halving  - Force recursive halving algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_REDUCE_SCATTER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REDUCE_SCATTER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_REDUCE_SCATTER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REDUCE_SCATTER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM);
        if (MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select reduce_scatter algorithm\
auto                        - Internal algorithm selection\
nb                          - Force nonblocking algorithm\
remote_reduce_local_scatter - Force remote-reduce-local-scatter algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_REDUCE_SCATTER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REDUCE_SCATTER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_REDUCE_SCATTER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REDUCE_SCATTER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM);
        if (MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_REDUCE_SCATTER_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_REDUCE_SCATTER_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Redscat will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level reduce_scatter function will not be called.");
    rc = MPL_env2bool("MPICH_REDUCE_SCATTER_DEVICE_COLLECTIVE", &(MPIR_CVAR_REDUCE_SCATTER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REDUCE_SCATTER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_REDUCE_SCATTER_DEVICE_COLLECTIVE", &(MPIR_CVAR_REDUCE_SCATTER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REDUCE_SCATTER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_REDUCE_SCATTER_DEVICE_COLLECTIVE", &(MPIR_CVAR_REDUCE_SCATTER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REDUCE_SCATTER_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ineighbor_alltoallv algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM);
        if (MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ineighbor_alltoallv algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM);
        if (MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_ineighbor_alltoallv will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level ineighbor_alltoallv function will not be called.");
    rc = MPL_env2bool("MPICH_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select neighbor_alltoallv algorithm\
auto - Internal algorithm selection\
nb   - Force nb algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM);
        if (MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select neighbor_alltoallv algorithm\
auto - Internal algorithm selection\
nb   - Force nb algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM);
        if (MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_neighbor_alltoallv will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level neighbor_alltoallv function will not be called.");
    rc = MPL_env2bool("MPICH_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE", &(MPIR_CVAR_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEIGHBOR_ALLTOALLV_DEVICE_COLLECTIVE");

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IBARRIER_RECEXCH_KVAL, /* name */
        &MPIR_CVAR_IBARRIER_RECEXCH_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for recursive exchange based ibarrier");
    rc = MPL_env2int("MPICH_IBARRIER_RECEXCH_KVAL", &(MPIR_CVAR_IBARRIER_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBARRIER_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IBARRIER_RECEXCH_KVAL", &(MPIR_CVAR_IBARRIER_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBARRIER_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IBARRIER_RECEXCH_KVAL", &(MPIR_CVAR_IBARRIER_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBARRIER_RECEXCH_KVAL");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IBARRIER_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IBARRIER_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ibarrier algorithm\
auto               - Internal algorithm selection\
recursive_doubling - Force recursive doubling algorithm\
recexch            - Force generic transport based recursive exchange algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IBARRIER_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IBARRIER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBARRIER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IBARRIER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBARRIER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IBARRIER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBARRIER_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IBARRIER_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IBARRIER_INTRA_ALGORITHM);
        if (MPIR_CVAR_IBARRIER_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IBARRIER_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IBARRIER_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IBARRIER_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IBARRIER_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ibarrier algorithm\
auto  - Internal algorithm selection\
bcast - Force bcast algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IBARRIER_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IBARRIER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBARRIER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IBARRIER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBARRIER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IBARRIER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBARRIER_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IBARRIER_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IBARRIER_INTER_ALGORITHM);
        if (MPIR_CVAR_IBARRIER_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IBARRIER_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IBARRIER_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IBARRIER_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IBARRIER_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Ibarrier will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level ibarrier function will not be called.");
    rc = MPL_env2bool("MPICH_IBARRIER_DEVICE_COLLECTIVE", &(MPIR_CVAR_IBARRIER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBARRIER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IBARRIER_DEVICE_COLLECTIVE", &(MPIR_CVAR_IBARRIER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBARRIER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IBARRIER_DEVICE_COLLECTIVE", &(MPIR_CVAR_IBARRIER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBARRIER_DEVICE_COLLECTIVE");

    defaultval.d = 8;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_BCAST_MIN_PROCS, /* name */
        &MPIR_CVAR_BCAST_MIN_PROCS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Let's define short messages as messages with size < MPIR_CVAR_BCAST_SHORT_MSG_SIZE, and medium messages as messages with size >= MPIR_CVAR_BCAST_SHORT_MSG_SIZE but < MPIR_CVAR_BCAST_LONG_MSG_SIZE, and long messages as messages with size >= MPIR_CVAR_BCAST_LONG_MSG_SIZE. The broadcast algorithms selection procedure is as follows. For short messages or when the number of processes is < MPIR_CVAR_BCAST_MIN_PROCS, we do broadcast using the binomial tree algorithm. Otherwise, for medium messages and with a power-of-two number of processes, we do broadcast based on a scatter followed by a recursive doubling allgather algorithm. Otherwise, for long messages or with non power-of-two number of processes, we do broadcast based on a scatter followed by a ring allgather algorithm. (See also: MPIR_CVAR_BCAST_SHORT_MSG_SIZE, MPIR_CVAR_BCAST_LONG_MSG_SIZE)");
    rc = MPL_env2int("MPICH_BCAST_MIN_PROCS", &(MPIR_CVAR_BCAST_MIN_PROCS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_BCAST_MIN_PROCS");
    rc = MPL_env2int("MPIR_PARAM_BCAST_MIN_PROCS", &(MPIR_CVAR_BCAST_MIN_PROCS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_BCAST_MIN_PROCS");
    rc = MPL_env2int("MPIR_CVAR_BCAST_MIN_PROCS", &(MPIR_CVAR_BCAST_MIN_PROCS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_BCAST_MIN_PROCS");

    defaultval.d = 12288;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_BCAST_SHORT_MSG_SIZE, /* name */
        &MPIR_CVAR_BCAST_SHORT_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Let's define short messages as messages with size < MPIR_CVAR_BCAST_SHORT_MSG_SIZE, and medium messages as messages with size >= MPIR_CVAR_BCAST_SHORT_MSG_SIZE but < MPIR_CVAR_BCAST_LONG_MSG_SIZE, and long messages as messages with size >= MPIR_CVAR_BCAST_LONG_MSG_SIZE. The broadcast algorithms selection procedure is as follows. For short messages or when the number of processes is < MPIR_CVAR_BCAST_MIN_PROCS, we do broadcast using the binomial tree algorithm. Otherwise, for medium messages and with a power-of-two number of processes, we do broadcast based on a scatter followed by a recursive doubling allgather algorithm. Otherwise, for long messages or with non power-of-two number of processes, we do broadcast based on a scatter followed by a ring allgather algorithm. (See also: MPIR_CVAR_BCAST_MIN_PROCS, MPIR_CVAR_BCAST_LONG_MSG_SIZE)");
    rc = MPL_env2int("MPICH_BCAST_SHORT_MSG_SIZE", &(MPIR_CVAR_BCAST_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_BCAST_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_BCAST_SHORT_MSG_SIZE", &(MPIR_CVAR_BCAST_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_BCAST_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_BCAST_SHORT_MSG_SIZE", &(MPIR_CVAR_BCAST_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_BCAST_SHORT_MSG_SIZE");

    defaultval.d = 524288;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_BCAST_LONG_MSG_SIZE, /* name */
        &MPIR_CVAR_BCAST_LONG_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Let's define short messages as messages with size < MPIR_CVAR_BCAST_SHORT_MSG_SIZE, and medium messages as messages with size >= MPIR_CVAR_BCAST_SHORT_MSG_SIZE but < MPIR_CVAR_BCAST_LONG_MSG_SIZE, and long messages as messages with size >= MPIR_CVAR_BCAST_LONG_MSG_SIZE. The broadcast algorithms selection procedure is as follows. For short messages or when the number of processes is < MPIR_CVAR_BCAST_MIN_PROCS, we do broadcast using the binomial tree algorithm. Otherwise, for medium messages and with a power-of-two number of processes, we do broadcast based on a scatter followed by a recursive doubling allgather algorithm. Otherwise, for long messages or with non power-of-two number of processes, we do broadcast based on a scatter followed by a ring allgather algorithm. (See also: MPIR_CVAR_BCAST_MIN_PROCS, MPIR_CVAR_BCAST_SHORT_MSG_SIZE)");
    rc = MPL_env2int("MPICH_BCAST_LONG_MSG_SIZE", &(MPIR_CVAR_BCAST_LONG_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_BCAST_LONG_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_BCAST_LONG_MSG_SIZE", &(MPIR_CVAR_BCAST_LONG_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_BCAST_LONG_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_BCAST_LONG_MSG_SIZE", &(MPIR_CVAR_BCAST_LONG_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_BCAST_LONG_MSG_SIZE");

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ENABLE_SMP_BCAST, /* name */
        &MPIR_CVAR_ENABLE_SMP_BCAST, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Enable SMP aware broadcast (See also: MPIR_CVAR_MAX_SMP_BCAST_MSG_SIZE)");
    rc = MPL_env2bool("MPICH_ENABLE_SMP_BCAST", &(MPIR_CVAR_ENABLE_SMP_BCAST));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ENABLE_SMP_BCAST");
    rc = MPL_env2bool("MPIR_PARAM_ENABLE_SMP_BCAST", &(MPIR_CVAR_ENABLE_SMP_BCAST));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ENABLE_SMP_BCAST");
    rc = MPL_env2bool("MPIR_CVAR_ENABLE_SMP_BCAST", &(MPIR_CVAR_ENABLE_SMP_BCAST));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ENABLE_SMP_BCAST");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_MAX_SMP_BCAST_MSG_SIZE, /* name */
        &MPIR_CVAR_MAX_SMP_BCAST_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Maximum message size for which SMP-aware broadcast is used.  A value of '0' uses SMP-aware broadcast for all message sizes. (See also: MPIR_CVAR_ENABLE_SMP_BCAST)");
    rc = MPL_env2int("MPICH_MAX_SMP_BCAST_MSG_SIZE", &(MPIR_CVAR_MAX_SMP_BCAST_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_MAX_SMP_BCAST_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_MAX_SMP_BCAST_MSG_SIZE", &(MPIR_CVAR_MAX_SMP_BCAST_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_MAX_SMP_BCAST_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_MAX_SMP_BCAST_MSG_SIZE", &(MPIR_CVAR_MAX_SMP_BCAST_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_MAX_SMP_BCAST_MSG_SIZE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_BCAST_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_BCAST_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select bcast algorithm\
auto                                    - Internal algorithm selection\
binomial                                - Force Binomial Tree\
nb                                      - Force nonblocking algorithm\
scatter_recursive_doubling_allgather    - Force Scatter Recursive-Doubling Allgather\
scatter_ring_allgather                  - Force Scatter Ring");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_BCAST_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_BCAST_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_BCAST_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_BCAST_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_BCAST_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_BCAST_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_BCAST_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_BCAST_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_BCAST_INTRA_ALGORITHM);
        if (MPIR_CVAR_BCAST_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_BCAST_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_BCAST_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_BCAST_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_BCAST_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select bcast algorithm\
auto                    - Internal algorithm selection\
nb                      - Force nonblocking algorithm\
remote_send_local_bcast - Force remote-send-local-bcast algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_BCAST_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_BCAST_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_BCAST_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_BCAST_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_BCAST_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_BCAST_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_BCAST_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_BCAST_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_BCAST_INTER_ALGORITHM);
        if (MPIR_CVAR_BCAST_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_BCAST_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_BCAST_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_BCAST_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_BCAST_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Bcast will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually.  If set to false, the device-level bcast function will not be called.");
    rc = MPL_env2bool("MPICH_BCAST_DEVICE_COLLECTIVE", &(MPIR_CVAR_BCAST_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_BCAST_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_BCAST_DEVICE_COLLECTIVE", &(MPIR_CVAR_BCAST_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_BCAST_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_BCAST_DEVICE_COLLECTIVE", &(MPIR_CVAR_BCAST_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_BCAST_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IGATHERV_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IGATHERV_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select igatherv algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IGATHERV_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IGATHERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IGATHERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IGATHERV_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IGATHERV_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IGATHERV_INTRA_ALGORITHM);
        if (MPIR_CVAR_IGATHERV_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IGATHERV_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IGATHERV_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IGATHERV_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IGATHERV_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select igatherv algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IGATHERV_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IGATHERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IGATHERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IGATHERV_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IGATHERV_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IGATHERV_INTER_ALGORITHM);
        if (MPIR_CVAR_IGATHERV_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IGATHERV_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IGATHERV_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IGATHERV_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IGATHERV_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Igatherv will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level igatherv function will not be called.");
    rc = MPL_env2bool("MPICH_IGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_IGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IGATHERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_IGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IGATHERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_IGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IGATHERV_DEVICE_COLLECTIVE");

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLGATHERV_RECEXCH_KVAL, /* name */
        &MPIR_CVAR_IALLGATHERV_RECEXCH_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for recursive exchange based iallgatherv");
    rc = MPL_env2int("MPICH_IALLGATHERV_RECEXCH_KVAL", &(MPIR_CVAR_IALLGATHERV_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLGATHERV_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IALLGATHERV_RECEXCH_KVAL", &(MPIR_CVAR_IALLGATHERV_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLGATHERV_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IALLGATHERV_RECEXCH_KVAL", &(MPIR_CVAR_IALLGATHERV_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLGATHERV_RECEXCH_KVAL");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select iallgatherv algorithm\
auto               - Internal algorithm selection\
brucks             - Force brucks algorithm\
recursive_doubling - Force recursive doubling algorithm\
ring               - Force ring algorithm\
recexch_distance_doubling    - Force generic transport recursive exchange with neighbours doubling in distance in each phase\
recexch_distance_halving     - Force generic transport recursive exchange with neighbours halving in distance in each phase\
gentran_ring              - Force generic transport ring algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IALLGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLGATHERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IALLGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLGATHERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM);
        if (MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select iallgatherv algorithm\
auto                      - Internal algorithm selection\
remote_gather_local_bcast - Force remote-gather-local-bcast algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IALLGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLGATHERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IALLGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLGATHERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM);
        if (MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLGATHERV_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IALLGATHERV_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Iallgatherv will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level iallgatherv function will not be called.");
    rc = MPL_env2bool("MPICH_IALLGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLGATHERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IALLGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLGATHERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IALLGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLGATHERV_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ISCAN_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_ISCAN_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select allgather algorithm\
auto               - Internal algorithm selection\
recursive_doubling - Force recursive doubling algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ISCAN_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ISCAN_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ISCAN_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ISCAN_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ISCAN_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ISCAN_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ISCAN_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ISCAN_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ISCAN_INTRA_ALGORITHM);
        if (MPIR_CVAR_ISCAN_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ISCAN_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ISCAN_INTRA_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ISCAN_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_ISCAN_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Iscan will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level iscan function will not be called.");
    rc = MPL_env2bool("MPICH_ISCAN_DEVICE_COLLECTIVE", &(MPIR_CVAR_ISCAN_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ISCAN_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_ISCAN_DEVICE_COLLECTIVE", &(MPIR_CVAR_ISCAN_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ISCAN_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_ISCAN_DEVICE_COLLECTIVE", &(MPIR_CVAR_ISCAN_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ISCAN_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_SCAN_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_SCAN_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select allgather algorithm\
auto               - Internal algorithm selection\
nb                 - Force nonblocking algorithm\
recursive_doubling - Force recursive doubling algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_SCAN_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_SCAN_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_SCAN_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_SCAN_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_SCAN_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_SCAN_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_SCAN_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_SCAN_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_SCAN_INTRA_ALGORITHM);
        if (MPIR_CVAR_SCAN_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_SCAN_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_SCAN_INTRA_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_SCAN_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_SCAN_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Scan will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level scan function will not be called.");
    rc = MPL_env2bool("MPICH_SCAN_DEVICE_COLLECTIVE", &(MPIR_CVAR_SCAN_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_SCAN_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_SCAN_DEVICE_COLLECTIVE", &(MPIR_CVAR_SCAN_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_SCAN_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_SCAN_DEVICE_COLLECTIVE", &(MPIR_CVAR_SCAN_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_SCAN_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ineighbor_alltoall algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM);
        if (MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ineighbor_alltoall algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_INEIGHBOR_ALLTOALL_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLTOALL_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_INEIGHBOR_ALLTOALL_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLTOALL_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM);
        if (MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_ineighbor_alltoall will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level ineighbor_alltoall function will not be called.");
    rc = MPL_env2bool("MPICH_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLTOALL_DEVICE_COLLECTIVE");

    defaultval.d = 2048;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_REDUCE_SHORT_MSG_SIZE, /* name */
        &MPIR_CVAR_REDUCE_SHORT_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "the short message algorithm will be used if the send buffer size is <= this value (in bytes)");
    rc = MPL_env2int("MPICH_REDUCE_SHORT_MSG_SIZE", &(MPIR_CVAR_REDUCE_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REDUCE_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_REDUCE_SHORT_MSG_SIZE", &(MPIR_CVAR_REDUCE_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REDUCE_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_REDUCE_SHORT_MSG_SIZE", &(MPIR_CVAR_REDUCE_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REDUCE_SHORT_MSG_SIZE");

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ENABLE_SMP_REDUCE, /* name */
        &MPIR_CVAR_ENABLE_SMP_REDUCE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Enable SMP aware reduce.");
    rc = MPL_env2bool("MPICH_ENABLE_SMP_REDUCE", &(MPIR_CVAR_ENABLE_SMP_REDUCE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ENABLE_SMP_REDUCE");
    rc = MPL_env2bool("MPIR_PARAM_ENABLE_SMP_REDUCE", &(MPIR_CVAR_ENABLE_SMP_REDUCE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ENABLE_SMP_REDUCE");
    rc = MPL_env2bool("MPIR_CVAR_ENABLE_SMP_REDUCE", &(MPIR_CVAR_ENABLE_SMP_REDUCE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ENABLE_SMP_REDUCE");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_MAX_SMP_REDUCE_MSG_SIZE, /* name */
        &MPIR_CVAR_MAX_SMP_REDUCE_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Maximum message size for which SMP-aware reduce is used.  A value of '0' uses SMP-aware reduce for all message sizes.");
    rc = MPL_env2int("MPICH_MAX_SMP_REDUCE_MSG_SIZE", &(MPIR_CVAR_MAX_SMP_REDUCE_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_MAX_SMP_REDUCE_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_MAX_SMP_REDUCE_MSG_SIZE", &(MPIR_CVAR_MAX_SMP_REDUCE_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_MAX_SMP_REDUCE_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_MAX_SMP_REDUCE_MSG_SIZE", &(MPIR_CVAR_MAX_SMP_REDUCE_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_MAX_SMP_REDUCE_MSG_SIZE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_REDUCE_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_REDUCE_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select reduce algorithm\
auto                  - Internal algorithm selection\
binomial              - Force binomial algorithm\
nb                    - Force nonblocking algorithm\
reduce_scatter_gather - Force reduce scatter gather algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_REDUCE_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_REDUCE_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REDUCE_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_REDUCE_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REDUCE_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_REDUCE_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REDUCE_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_REDUCE_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_REDUCE_INTRA_ALGORITHM);
        if (MPIR_CVAR_REDUCE_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_REDUCE_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_REDUCE_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_REDUCE_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_REDUCE_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select reduce algorithm\
auto                     - Internal algorithm selection\
local_reduce_remote_send - Force local-reduce-remote-send algorithm\
nb                       - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_REDUCE_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_REDUCE_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REDUCE_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_REDUCE_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REDUCE_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_REDUCE_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REDUCE_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_REDUCE_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_REDUCE_INTER_ALGORITHM);
        if (MPIR_CVAR_REDUCE_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_REDUCE_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_REDUCE_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_REDUCE_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_REDUCE_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Reduce will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level reduce function will not be called.");
    rc = MPL_env2bool("MPICH_REDUCE_DEVICE_COLLECTIVE", &(MPIR_CVAR_REDUCE_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REDUCE_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_REDUCE_DEVICE_COLLECTIVE", &(MPIR_CVAR_REDUCE_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REDUCE_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_REDUCE_DEVICE_COLLECTIVE", &(MPIR_CVAR_REDUCE_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REDUCE_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select alltoallw algorithm\
auto                      - Internal algorithm selection\
nb                        - Force nonblocking algorithm\
pairwise_sendrecv_replace - Force pairwise sendrecv replace algorithm\
scattered                 - Force scattered algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ALLTOALLW_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLTOALLW_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ALLTOALLW_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLTOALLW_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM);
        if (MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select alltoallw algorithm\
auto              - Internal algorithm selection\
nb                - Force nonblocking algorithm\
pairwise_exchange - Force pairwise exchange algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ALLTOALLW_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLTOALLW_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ALLTOALLW_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLTOALLW_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM);
        if (MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ALLTOALLW_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_ALLTOALLW_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Alltoallw will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level alltoallw function will not be called.");
    rc = MPL_env2bool("MPICH_ALLTOALLW_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLTOALLW_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ALLTOALLW_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_ALLTOALLW_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLTOALLW_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ALLTOALLW_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_ALLTOALLW_DEVICE_COLLECTIVE", &(MPIR_CVAR_ALLTOALLW_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ALLTOALLW_DEVICE_COLLECTIVE");

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ENABLE_SMP_BARRIER, /* name */
        &MPIR_CVAR_ENABLE_SMP_BARRIER, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Enable SMP aware barrier.");
    rc = MPL_env2bool("MPICH_ENABLE_SMP_BARRIER", &(MPIR_CVAR_ENABLE_SMP_BARRIER));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ENABLE_SMP_BARRIER");
    rc = MPL_env2bool("MPIR_PARAM_ENABLE_SMP_BARRIER", &(MPIR_CVAR_ENABLE_SMP_BARRIER));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ENABLE_SMP_BARRIER");
    rc = MPL_env2bool("MPIR_CVAR_ENABLE_SMP_BARRIER", &(MPIR_CVAR_ENABLE_SMP_BARRIER));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ENABLE_SMP_BARRIER");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_BARRIER_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_BARRIER_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select barrier algorithm\
auto               - Internal algorithm selection\
nb                 - Force nonblocking algorithm\
recursive_doubling - Force recursive doubling algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_BARRIER_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_BARRIER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_BARRIER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_BARRIER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_BARRIER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_BARRIER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_BARRIER_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_BARRIER_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_BARRIER_INTRA_ALGORITHM);
        if (MPIR_CVAR_BARRIER_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_BARRIER_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_BARRIER_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_BARRIER_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_BARRIER_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select barrier algorithm\
auto  - Internal algorithm selection\
bcast - Force bcast algorithm\
nb    - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_BARRIER_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_BARRIER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_BARRIER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_BARRIER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_BARRIER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_BARRIER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_BARRIER_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_BARRIER_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_BARRIER_INTER_ALGORITHM);
        if (MPIR_CVAR_BARRIER_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_BARRIER_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_BARRIER_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_BARRIER_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_BARRIER_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Barrier will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level barrier function will not be called.");
    rc = MPL_env2bool("MPICH_BARRIER_DEVICE_COLLECTIVE", &(MPIR_CVAR_BARRIER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_BARRIER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_BARRIER_DEVICE_COLLECTIVE", &(MPIR_CVAR_BARRIER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_BARRIER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_BARRIER_DEVICE_COLLECTIVE", &(MPIR_CVAR_BARRIER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_BARRIER_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select iscatterv algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ISCATTERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ISCATTERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ISCATTERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ISCATTERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM);
        if (MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_ISCATTERV_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_ISCATTERV_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select iscatterv algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_ISCATTERV_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_ISCATTERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ISCATTERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_ISCATTERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ISCATTERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_ISCATTERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ISCATTERV_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_ISCATTERV_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_ISCATTERV_INTER_ALGORITHM);
        if (MPIR_CVAR_ISCATTERV_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_ISCATTERV_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_ISCATTERV_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ISCATTERV_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_ISCATTERV_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Iscatterv will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level iscatterv function will not be called.");
    rc = MPL_env2bool("MPICH_ISCATTERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_ISCATTERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ISCATTERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_ISCATTERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_ISCATTERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ISCATTERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_ISCATTERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_ISCATTERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ISCATTERV_DEVICE_COLLECTIVE");

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_DEVICE_COLLECTIVES, /* name */
        &MPIR_CVAR_DEVICE_COLLECTIVES, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI collectives will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually.  If set to false, the device-level collective function will not be called.");
    rc = MPL_env2bool("MPICH_DEVICE_COLLECTIVES", &(MPIR_CVAR_DEVICE_COLLECTIVES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_DEVICE_COLLECTIVES");
    rc = MPL_env2bool("MPIR_PARAM_DEVICE_COLLECTIVES", &(MPIR_CVAR_DEVICE_COLLECTIVES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_DEVICE_COLLECTIVES");
    rc = MPL_env2bool("MPIR_CVAR_DEVICE_COLLECTIVES", &(MPIR_CVAR_DEVICE_COLLECTIVES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_DEVICE_COLLECTIVES");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ineighbor_allgatherv algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM);
        if (MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ineighbor_allgatherv algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM);
        if (MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_ineighbor_allgatherv will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level ineighbor_allgatherv function will not be called.");
    rc = MPL_env2bool("MPICH_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLGATHERV_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_SCATTERV_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_SCATTERV_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select scatterv algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm\
nb     - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_SCATTERV_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_SCATTERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_SCATTERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_SCATTERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_SCATTERV_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_SCATTERV_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_SCATTERV_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_SCATTERV_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_SCATTERV_INTRA_ALGORITHM);
        if (MPIR_CVAR_SCATTERV_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_SCATTERV_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_SCATTERV_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_SCATTERV_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_SCATTERV_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select scatterv algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm\
nb     - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_SCATTERV_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_SCATTERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_SCATTERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_SCATTERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_SCATTERV_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_SCATTERV_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_SCATTERV_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_SCATTERV_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_SCATTERV_INTER_ALGORITHM);
        if (MPIR_CVAR_SCATTERV_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_SCATTERV_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_SCATTERV_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_SCATTERV_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_SCATTERV_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_scatterv will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level scatterv function will not be called.");
    rc = MPL_env2bool("MPICH_SCATTERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_SCATTERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_SCATTERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_SCATTERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_SCATTERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_SCATTERV_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_SCATTERV_DEVICE_COLLECTIVE", &(MPIR_CVAR_SCATTERV_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_SCATTERV_DEVICE_COLLECTIVE");

    defaultval.d = 1024;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_GATHER_VSMALL_MSG_SIZE, /* name */
        &MPIR_CVAR_GATHER_VSMALL_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "use a temporary buffer for intracommunicator MPI_Gather if the send buffer size is < this value (in bytes) (See also: MPIR_CVAR_GATHER_INTER_SHORT_MSG_SIZE)");
    rc = MPL_env2int("MPICH_GATHER_VSMALL_MSG_SIZE", &(MPIR_CVAR_GATHER_VSMALL_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_GATHER_VSMALL_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_GATHER_VSMALL_MSG_SIZE", &(MPIR_CVAR_GATHER_VSMALL_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_GATHER_VSMALL_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_GATHER_VSMALL_MSG_SIZE", &(MPIR_CVAR_GATHER_VSMALL_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_GATHER_VSMALL_MSG_SIZE");

    defaultval.d = 2048;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_GATHER_INTER_SHORT_MSG_SIZE, /* name */
        &MPIR_CVAR_GATHER_INTER_SHORT_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "use the short message algorithm for intercommunicator MPI_Gather if the send buffer size is < this value (in bytes) (See also: MPIR_CVAR_GATHER_VSMALL_MSG_SIZE)");
    rc = MPL_env2int("MPICH_GATHER_INTER_SHORT_MSG_SIZE", &(MPIR_CVAR_GATHER_INTER_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_GATHER_INTER_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_GATHER_INTER_SHORT_MSG_SIZE", &(MPIR_CVAR_GATHER_INTER_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_GATHER_INTER_SHORT_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_GATHER_INTER_SHORT_MSG_SIZE", &(MPIR_CVAR_GATHER_INTER_SHORT_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_GATHER_INTER_SHORT_MSG_SIZE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_GATHER_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_GATHER_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select gather algorithm\
auto     - Internal algorithm selection\
binomial - Force binomial algorithm\
nb       - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_GATHER_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_GATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_GATHER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_GATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_GATHER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_GATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_GATHER_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_GATHER_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_GATHER_INTRA_ALGORITHM);
        if (MPIR_CVAR_GATHER_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_GATHER_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_GATHER_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_GATHER_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_GATHER_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select gather algorithm\
auto                     - Internal algorithm selection\
linear                   - Force linear algorithm\
local_gather_remote_send - Force local-gather-remote-send algorithm\
nb                       - Force nonblocking algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_GATHER_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_GATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_GATHER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_GATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_GATHER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_GATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_GATHER_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_GATHER_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_GATHER_INTER_ALGORITHM);
        if (MPIR_CVAR_GATHER_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_GATHER_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_GATHER_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_GATHER_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_GATHER_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Gather will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level gather function will not be called.");
    rc = MPL_env2bool("MPICH_GATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_GATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_GATHER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_GATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_GATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_GATHER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_GATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_GATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_GATHER_DEVICE_COLLECTIVE");

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL, /* name */
        &MPIR_CVAR_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for recursive exchange based ireduce_scatter_block");
    rc = MPL_env2int("MPICH_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL", &(MPIR_CVAR_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL", &(MPIR_CVAR_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL", &(MPIR_CVAR_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_SCATTER_BLOCK_RECEXCH_KVAL");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ireduce_scatter_block algorithm\
auto               - Internal algorithm selection\
noncommutative     - Force noncommutative algorithm\
recursive_doubling - Force recursive doubling algorithm\
pairwise           - Force pairwise algorithm\
recursive_halving  - Force recursive halving algorithm\
recexch  - Force generic transport recursive exchange algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM);
        if (MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ireduce_scatter_block algorithm\
auto                         - Internal algorithm selection\
remote_reduce_local_scatterv - Force remote-reduce-local-scatterv algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM);
        if (MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Ireduce_scatter_block will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level ireduce_scatter_block function will not be called.");
    rc = MPL_env2bool("MPICH_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE", &(MPIR_CVAR_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE", &(MPIR_CVAR_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE", &(MPIR_CVAR_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IREDUCE_SCATTER_BLOCK_DEVICE_COLLECTIVE");

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLGATHER_RECEXCH_KVAL, /* name */
        &MPIR_CVAR_IALLGATHER_RECEXCH_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for recursive exchange based iallgather");
    rc = MPL_env2int("MPICH_IALLGATHER_RECEXCH_KVAL", &(MPIR_CVAR_IALLGATHER_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLGATHER_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IALLGATHER_RECEXCH_KVAL", &(MPIR_CVAR_IALLGATHER_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLGATHER_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IALLGATHER_RECEXCH_KVAL", &(MPIR_CVAR_IALLGATHER_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLGATHER_RECEXCH_KVAL");

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLGATHER_BRUCKS_KVAL, /* name */
        &MPIR_CVAR_IALLGATHER_BRUCKS_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for radix in brucks based iallgather");
    rc = MPL_env2int("MPICH_IALLGATHER_BRUCKS_KVAL", &(MPIR_CVAR_IALLGATHER_BRUCKS_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLGATHER_BRUCKS_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IALLGATHER_BRUCKS_KVAL", &(MPIR_CVAR_IALLGATHER_BRUCKS_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLGATHER_BRUCKS_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IALLGATHER_BRUCKS_KVAL", &(MPIR_CVAR_IALLGATHER_BRUCKS_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLGATHER_BRUCKS_KVAL");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select iallgather algorithm\
auto               - Internal algorithm selection\
brucks             - Force brucks algorithm\
recursive_doubling - Force recursive doubling algorithm\
ring               - Force ring algorithm\
recexch_distance_doubling    - Force generic transport recursive exchange with neighbours doubling in distance in each phase\
recexch_distance_halving  - Force generic transport recursive exchange with neighbours halving in distance in each phase\
gentran_brucks     - Force generic transport based brucks algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IALLGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLGATHER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IALLGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLGATHER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM);
        if (MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IALLGATHER_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IALLGATHER_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select iallgather algorithm\
auto                      - Internal algorithm selection\
local_gather_remote_bcast - Force local-gather-remote-bcast algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IALLGATHER_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IALLGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLGATHER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IALLGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLGATHER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IALLGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLGATHER_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IALLGATHER_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IALLGATHER_INTER_ALGORITHM);
        if (MPIR_CVAR_IALLGATHER_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IALLGATHER_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IALLGATHER_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IALLGATHER_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IALLGATHER_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Iallgather will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level iallgather function will not be called.");
    rc = MPL_env2bool("MPICH_IALLGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IALLGATHER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IALLGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IALLGATHER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IALLGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_IALLGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IALLGATHER_DEVICE_COLLECTIVE");

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IBCAST_TREE_KVAL, /* name */
        &MPIR_CVAR_IBCAST_TREE_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for tree (kary, knomial, etc.) based ibcast");
    rc = MPL_env2int("MPICH_IBCAST_TREE_KVAL", &(MPIR_CVAR_IBCAST_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBCAST_TREE_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IBCAST_TREE_KVAL", &(MPIR_CVAR_IBCAST_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBCAST_TREE_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IBCAST_TREE_KVAL", &(MPIR_CVAR_IBCAST_TREE_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBCAST_TREE_KVAL");

    defaultval.str = (char *)"kary";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IBCAST_TREE_TYPE, /* name */
        &MPIR_CVAR_IBCAST_TREE_TYPE, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Tree type for tree based ibcast kary      - kary tree type knomial_1 - knomial_1 tree type knomial_2 - knomial_2 tree type");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IBCAST_TREE_TYPE, &tmp_str);
    rc = MPL_env2str("MPICH_IBCAST_TREE_TYPE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBCAST_TREE_TYPE");
    rc = MPL_env2str("MPIR_PARAM_IBCAST_TREE_TYPE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBCAST_TREE_TYPE");
    rc = MPL_env2str("MPIR_CVAR_IBCAST_TREE_TYPE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBCAST_TREE_TYPE");
    if (tmp_str != NULL) {
        MPIR_CVAR_IBCAST_TREE_TYPE = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IBCAST_TREE_TYPE);
        if (MPIR_CVAR_IBCAST_TREE_TYPE == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IBCAST_TREE_TYPE");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IBCAST_TREE_TYPE = NULL;
    }

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IBCAST_TREE_PIPELINE_CHUNK_SIZE, /* name */
        &MPIR_CVAR_IBCAST_TREE_PIPELINE_CHUNK_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Maximum chunk size (in bytes) for pipelining in tree based ibcast. Default value is 0, that is, no pipelining by default");
    rc = MPL_env2int("MPICH_IBCAST_TREE_PIPELINE_CHUNK_SIZE", &(MPIR_CVAR_IBCAST_TREE_PIPELINE_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBCAST_TREE_PIPELINE_CHUNK_SIZE");
    rc = MPL_env2int("MPIR_PARAM_IBCAST_TREE_PIPELINE_CHUNK_SIZE", &(MPIR_CVAR_IBCAST_TREE_PIPELINE_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBCAST_TREE_PIPELINE_CHUNK_SIZE");
    rc = MPL_env2int("MPIR_CVAR_IBCAST_TREE_PIPELINE_CHUNK_SIZE", &(MPIR_CVAR_IBCAST_TREE_PIPELINE_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBCAST_TREE_PIPELINE_CHUNK_SIZE");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IBCAST_RING_CHUNK_SIZE, /* name */
        &MPIR_CVAR_IBCAST_RING_CHUNK_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Maximum chunk size (in bytes) for pipelining in ibcast ring algorithm. Default value is 0, that is, no pipelining by default");
    rc = MPL_env2int("MPICH_IBCAST_RING_CHUNK_SIZE", &(MPIR_CVAR_IBCAST_RING_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBCAST_RING_CHUNK_SIZE");
    rc = MPL_env2int("MPIR_PARAM_IBCAST_RING_CHUNK_SIZE", &(MPIR_CVAR_IBCAST_RING_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBCAST_RING_CHUNK_SIZE");
    rc = MPL_env2int("MPIR_CVAR_IBCAST_RING_CHUNK_SIZE", &(MPIR_CVAR_IBCAST_RING_CHUNK_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBCAST_RING_CHUNK_SIZE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IBCAST_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_IBCAST_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ibcast algorithm\
auto                                 - Internal algorithm selection\
binomial                             - Force Binomial algorithm\
scatter_recursive_doubling_allgather - Force Scatter Recursive Doubling Allgather algorithm\
scatter_ring_allgather               - Force Scatter Ring Allgather algorithm\
tree                                 - Force Generic Transport Tree algorithm\
scatter_recexch_allgather            - Force Generic Transport Scatter followed by Recursive Exchange Allgather algorithm\
ring                                 - Force Generic Transport Ring algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IBCAST_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IBCAST_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBCAST_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IBCAST_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBCAST_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IBCAST_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBCAST_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IBCAST_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IBCAST_INTRA_ALGORITHM);
        if (MPIR_CVAR_IBCAST_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IBCAST_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IBCAST_INTRA_ALGORITHM = NULL;
    }

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IBCAST_SCATTER_KVAL, /* name */
        &MPIR_CVAR_IBCAST_SCATTER_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for tree based scatter in scatter_recexch_allgather algorithm");
    rc = MPL_env2int("MPICH_IBCAST_SCATTER_KVAL", &(MPIR_CVAR_IBCAST_SCATTER_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBCAST_SCATTER_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IBCAST_SCATTER_KVAL", &(MPIR_CVAR_IBCAST_SCATTER_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBCAST_SCATTER_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IBCAST_SCATTER_KVAL", &(MPIR_CVAR_IBCAST_SCATTER_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBCAST_SCATTER_KVAL");

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IBCAST_ALLGATHER_RECEXCH_KVAL, /* name */
        &MPIR_CVAR_IBCAST_ALLGATHER_RECEXCH_KVAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "k value for recursive exchange based allgather in scatter_recexch_allgather algorithm");
    rc = MPL_env2int("MPICH_IBCAST_ALLGATHER_RECEXCH_KVAL", &(MPIR_CVAR_IBCAST_ALLGATHER_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBCAST_ALLGATHER_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_PARAM_IBCAST_ALLGATHER_RECEXCH_KVAL", &(MPIR_CVAR_IBCAST_ALLGATHER_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBCAST_ALLGATHER_RECEXCH_KVAL");
    rc = MPL_env2int("MPIR_CVAR_IBCAST_ALLGATHER_RECEXCH_KVAL", &(MPIR_CVAR_IBCAST_ALLGATHER_RECEXCH_KVAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBCAST_ALLGATHER_RECEXCH_KVAL");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_IBCAST_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_IBCAST_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ibcast algorithm\
auto - Internal algorithm selection\
flat - Force flat algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_IBCAST_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_IBCAST_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBCAST_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_IBCAST_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBCAST_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_IBCAST_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBCAST_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_IBCAST_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_IBCAST_INTER_ALGORITHM);
        if (MPIR_CVAR_IBCAST_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_IBCAST_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_IBCAST_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_IBCAST_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_IBCAST_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_Ibcast will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually.  If set to false, the device-level ibcast function will not be called.");
    rc = MPL_env2bool("MPICH_IBCAST_DEVICE_COLLECTIVE", &(MPIR_CVAR_IBCAST_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_IBCAST_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_IBCAST_DEVICE_COLLECTIVE", &(MPIR_CVAR_IBCAST_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_IBCAST_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_IBCAST_DEVICE_COLLECTIVE", &(MPIR_CVAR_IBCAST_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_IBCAST_DEVICE_COLLECTIVE");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ineighbor_allgather algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM);
        if (MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM = NULL;
    }

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Variable to select ineighbor_allgather algorithm\
auto   - Internal algorithm selection\
linear - Force linear algorithm");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM, &tmp_str);
    rc = MPL_env2str("MPICH_INEIGHBOR_ALLGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLGATHER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_PARAM_INEIGHBOR_ALLGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLGATHER_INTER_ALGORITHM");
    rc = MPL_env2str("MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM);
        if (MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE, /* name */
        &MPIR_CVAR_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "If set to true, MPI_ineighbor_allgather will allow the device to override the MPIR-level collective algorithms. The device still has the option to call the MPIR-level algorithms manually. If set to false, the device-level ineighbor_allgather function will not be called.");
    rc = MPL_env2bool("MPICH_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_PARAM_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE");
    rc = MPL_env2bool("MPIR_CVAR_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE", &(MPIR_CVAR_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INEIGHBOR_ALLGATHER_DEVICE_COLLECTIVE");

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_MEMDUMP, /* name */
        &MPIR_CVAR_MEMDUMP, /* address */
        1, /* count */
        MPI_T_VERBOSITY_MPIDEV_DETAIL,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "DEVELOPER", /* category */
        "If true, list any memory that was allocated by MPICH and that remains allocated when MPI_Finalize completes.");
    rc = MPL_env2bool("MPICH_MEMDUMP", &(MPIR_CVAR_MEMDUMP));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_MEMDUMP");
    rc = MPL_env2bool("MPIR_PARAM_MEMDUMP", &(MPIR_CVAR_MEMDUMP));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_MEMDUMP");
    rc = MPL_env2bool("MPIR_CVAR_MEMDUMP", &(MPIR_CVAR_MEMDUMP));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_MEMDUMP");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_MEM_CATEGORY_INFORMATION, /* name */
        &MPIR_CVAR_MEM_CATEGORY_INFORMATION, /* address */
        1, /* count */
        MPI_T_VERBOSITY_MPIDEV_DETAIL,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "DEVELOPER", /* category */
        "If true, print a summary of memory allocation by category. The category definitions are found in mpl_trmem.h.");
    rc = MPL_env2bool("MPICH_MEM_CATEGORY_INFORMATION", &(MPIR_CVAR_MEM_CATEGORY_INFORMATION));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_MEM_CATEGORY_INFORMATION");
    rc = MPL_env2bool("MPIR_PARAM_MEM_CATEGORY_INFORMATION", &(MPIR_CVAR_MEM_CATEGORY_INFORMATION));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_MEM_CATEGORY_INFORMATION");
    rc = MPL_env2bool("MPIR_CVAR_MEM_CATEGORY_INFORMATION", &(MPIR_CVAR_MEM_CATEGORY_INFORMATION));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_MEM_CATEGORY_INFORMATION");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_DEBUG_HOLD, /* name */
        &MPIR_CVAR_DEBUG_HOLD, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "DEBUGGER", /* category */
        "If true, causes processes to wait in MPI_Init and MPI_Initthread for a debugger to be attached.  Once the debugger has attached, the variable 'hold' should be set to 0 in order to allow the process to continue (e.g., in gdb, \"set hold=0\").");
    rc = MPL_env2bool("MPICH_DEBUG_HOLD", &(MPIR_CVAR_DEBUG_HOLD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_DEBUG_HOLD");
    rc = MPL_env2bool("MPIR_PARAM_DEBUG_HOLD", &(MPIR_CVAR_DEBUG_HOLD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_DEBUG_HOLD");
    rc = MPL_env2bool("MPIR_CVAR_DEBUG_HOLD", &(MPIR_CVAR_DEBUG_HOLD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_DEBUG_HOLD");

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ERROR_CHECKING, /* name */
        &MPIR_CVAR_ERROR_CHECKING, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "ERROR_HANDLING", /* category */
        "If true, perform checks for errors, typically to verify valid inputs to MPI routines.  Only effective when MPICH is configured with --enable-error-checking=runtime .");
    rc = MPL_env2bool("MPICH_ERROR_CHECKING", &(MPIR_CVAR_ERROR_CHECKING));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ERROR_CHECKING");
    rc = MPL_env2bool("MPIR_PARAM_ERROR_CHECKING", &(MPIR_CVAR_ERROR_CHECKING));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ERROR_CHECKING");
    rc = MPL_env2bool("MPIR_CVAR_ERROR_CHECKING", &(MPIR_CVAR_ERROR_CHECKING));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ERROR_CHECKING");

    defaultval.str = (char *)"auto";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NETLOC_NODE_FILE, /* name */
        &MPIR_CVAR_NETLOC_NODE_FILE, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "DEBUGGER", /* category */
        "Subnet json file");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NETLOC_NODE_FILE, &tmp_str);
    rc = MPL_env2str("MPICH_NETLOC_NODE_FILE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NETLOC_NODE_FILE");
    rc = MPL_env2str("MPIR_PARAM_NETLOC_NODE_FILE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NETLOC_NODE_FILE");
    rc = MPL_env2str("MPIR_CVAR_NETLOC_NODE_FILE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NETLOC_NODE_FILE");
    if (tmp_str != NULL) {
        MPIR_CVAR_NETLOC_NODE_FILE = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NETLOC_NODE_FILE);
        if (MPIR_CVAR_NETLOC_NODE_FILE == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NETLOC_NODE_FILE");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NETLOC_NODE_FILE = NULL;
    }

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_SUPPRESS_ABORT_MESSAGE, /* name */
        &MPIR_CVAR_SUPPRESS_ABORT_MESSAGE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "ERROR_HANDLING", /* category */
        "Disable printing of abort error message.");
    rc = MPL_env2bool("MPICH_SUPPRESS_ABORT_MESSAGE", &(MPIR_CVAR_SUPPRESS_ABORT_MESSAGE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_SUPPRESS_ABORT_MESSAGE");
    rc = MPL_env2bool("MPIR_PARAM_SUPPRESS_ABORT_MESSAGE", &(MPIR_CVAR_SUPPRESS_ABORT_MESSAGE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_SUPPRESS_ABORT_MESSAGE");
    rc = MPL_env2bool("MPIR_CVAR_SUPPRESS_ABORT_MESSAGE", &(MPIR_CVAR_SUPPRESS_ABORT_MESSAGE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_SUPPRESS_ABORT_MESSAGE");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ASYNC_PROGRESS, /* name */
        &MPIR_CVAR_ASYNC_PROGRESS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "THREADS", /* category */
        "If set to true, MPICH will initiate an additional thread to make asynchronous progress on all communication operations including point-to-point, collective, one-sided operations and I/O.  Setting this variable will automatically increase the thread-safety level to MPI_THREAD_MULTIPLE.  While this improves the progress semantics, it might cause a small amount of performance overhead for regular MPI operations.  The user is encouraged to leave one or more hardware threads vacant in order to prevent contention between the application threads and the progress thread(s).  The impact of oversubscription is highly system dependent but may be substantial in some cases, hence this recommendation.");
    rc = MPL_env2bool("MPICH_ASYNC_PROGRESS", &(MPIR_CVAR_ASYNC_PROGRESS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ASYNC_PROGRESS");
    rc = MPL_env2bool("MPIR_PARAM_ASYNC_PROGRESS", &(MPIR_CVAR_ASYNC_PROGRESS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ASYNC_PROGRESS");
    rc = MPL_env2bool("MPIR_CVAR_ASYNC_PROGRESS", &(MPIR_CVAR_ASYNC_PROGRESS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ASYNC_PROGRESS");

    defaultval.str = (char *)"MPI_THREAD_SINGLE";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_DEFAULT_THREAD_LEVEL, /* name */
        &MPIR_CVAR_DEFAULT_THREAD_LEVEL, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "THREADS", /* category */
        "Sets the default thread level to use when using MPI_INIT. This variable is case-insensitive.");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_DEFAULT_THREAD_LEVEL, &tmp_str);
    rc = MPL_env2str("MPICH_DEFAULT_THREAD_LEVEL", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_DEFAULT_THREAD_LEVEL");
    rc = MPL_env2str("MPIR_PARAM_DEFAULT_THREAD_LEVEL", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_DEFAULT_THREAD_LEVEL");
    rc = MPL_env2str("MPIR_CVAR_DEFAULT_THREAD_LEVEL", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_DEFAULT_THREAD_LEVEL");
    if (tmp_str != NULL) {
        MPIR_CVAR_DEFAULT_THREAD_LEVEL = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_DEFAULT_THREAD_LEVEL);
        if (MPIR_CVAR_DEFAULT_THREAD_LEVEL == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_DEFAULT_THREAD_LEVEL");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_DEFAULT_THREAD_LEVEL = NULL;
    }

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_COMM_SPLIT_USE_QSORT, /* name */
        &MPIR_CVAR_COMM_SPLIT_USE_QSORT, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COMMUNICATOR", /* category */
        "Use qsort(3) in the implementation of MPI_Comm_split instead of bubble sort.");
    rc = MPL_env2bool("MPICH_COMM_SPLIT_USE_QSORT", &(MPIR_CVAR_COMM_SPLIT_USE_QSORT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_COMM_SPLIT_USE_QSORT");
    rc = MPL_env2bool("MPIR_PARAM_COMM_SPLIT_USE_QSORT", &(MPIR_CVAR_COMM_SPLIT_USE_QSORT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_COMM_SPLIT_USE_QSORT");
    rc = MPL_env2bool("MPIR_CVAR_COMM_SPLIT_USE_QSORT", &(MPIR_CVAR_COMM_SPLIT_USE_QSORT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_COMM_SPLIT_USE_QSORT");

    defaultval.d = 2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CTXID_EAGER_SIZE, /* name */
        &MPIR_CVAR_CTXID_EAGER_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "THREADS", /* category */
        "The MPIR_CVAR_CTXID_EAGER_SIZE environment variable allows you to specify how many words in the context ID mask will be set aside for the eager allocation protocol.  If the application is running out of context IDs, reducing this value may help.");
    rc = MPL_env2int("MPICH_CTXID_EAGER_SIZE", &(MPIR_CVAR_CTXID_EAGER_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CTXID_EAGER_SIZE");
    rc = MPL_env2int("MPIR_PARAM_CTXID_EAGER_SIZE", &(MPIR_CVAR_CTXID_EAGER_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CTXID_EAGER_SIZE");
    rc = MPL_env2int("MPIR_CVAR_CTXID_EAGER_SIZE", &(MPIR_CVAR_CTXID_EAGER_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CTXID_EAGER_SIZE");

    defaultval.d = 64;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_PROCTABLE_SIZE, /* name */
        &MPIR_CVAR_PROCTABLE_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "DEBUGGER", /* category */
        "Size of the \"MPIR\" debugger interface proctable (process table).");
    rc = MPL_env2int("MPICH_PROCTABLE_SIZE", &(MPIR_CVAR_PROCTABLE_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_PROCTABLE_SIZE");
    rc = MPL_env2int("MPIR_PARAM_PROCTABLE_SIZE", &(MPIR_CVAR_PROCTABLE_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_PROCTABLE_SIZE");
    rc = MPL_env2int("MPIR_CVAR_PROCTABLE_SIZE", &(MPIR_CVAR_PROCTABLE_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_PROCTABLE_SIZE");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_PROCTABLE_PRINT, /* name */
        &MPIR_CVAR_PROCTABLE_PRINT, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "DEBUGGER", /* category */
        "If true, dump the proctable entries at MPII_Wait_for_debugger-time.");
    rc = MPL_env2bool("MPICH_PROCTABLE_PRINT", &(MPIR_CVAR_PROCTABLE_PRINT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_PROCTABLE_PRINT");
    rc = MPL_env2bool("MPIR_PARAM_PROCTABLE_PRINT", &(MPIR_CVAR_PROCTABLE_PRINT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_PROCTABLE_PRINT");
    rc = MPL_env2bool("MPIR_CVAR_PROCTABLE_PRINT", &(MPIR_CVAR_PROCTABLE_PRINT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_PROCTABLE_PRINT");

    defaultval.str = (char *)NULL;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NAMESERV_FILE_PUBDIR, /* name */
        &MPIR_CVAR_NAMESERV_FILE_PUBDIR, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "PROCESS_MANAGER", /* category */
        "Sets the directory to use for MPI service publishing in the file nameserv implementation.  Allows the user to override where the publish and lookup information is placed for connect/accept based applications.");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NAMESERV_FILE_PUBDIR, &tmp_str);
    rc = MPL_env2str("MPICH_NAMEPUB_DIR", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NAMEPUB_DIR");
    rc = MPL_env2str("MPIR_PARAM_NAMEPUB_DIR", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NAMEPUB_DIR");
    rc = MPL_env2str("MPIR_CVAR_NAMEPUB_DIR", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NAMEPUB_DIR");
    rc = MPL_env2str("MPICH_NAMESERV_FILE_PUBDIR", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NAMESERV_FILE_PUBDIR");
    rc = MPL_env2str("MPIR_PARAM_NAMESERV_FILE_PUBDIR", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NAMESERV_FILE_PUBDIR");
    rc = MPL_env2str("MPIR_CVAR_NAMESERV_FILE_PUBDIR", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NAMESERV_FILE_PUBDIR");
    if (tmp_str != NULL) {
        MPIR_CVAR_NAMESERV_FILE_PUBDIR = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NAMESERV_FILE_PUBDIR);
        if (MPIR_CVAR_NAMESERV_FILE_PUBDIR == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NAMESERV_FILE_PUBDIR");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NAMESERV_FILE_PUBDIR = NULL;
    }

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ABORT_ON_LEAKED_HANDLES, /* name */
        &MPIR_CVAR_ABORT_ON_LEAKED_HANDLES, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "MEMORY", /* category */
        "If true, MPI will call MPI_Abort at MPI_Finalize if any MPI object handles have been leaked.  For example, if MPI_Comm_dup is called without calling a corresponding MPI_Comm_free.  For uninteresting reasons, enabling this option may prevent all known object leaks from being reported.  MPICH must have been configure with \"--enable-g=handlealloc\" or better in order for this functionality to work.");
    rc = MPL_env2bool("MPICH_ABORT_ON_LEAKED_HANDLES", &(MPIR_CVAR_ABORT_ON_LEAKED_HANDLES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ABORT_ON_LEAKED_HANDLES");
    rc = MPL_env2bool("MPIR_PARAM_ABORT_ON_LEAKED_HANDLES", &(MPIR_CVAR_ABORT_ON_LEAKED_HANDLES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ABORT_ON_LEAKED_HANDLES");
    rc = MPL_env2bool("MPIR_CVAR_ABORT_ON_LEAKED_HANDLES", &(MPIR_CVAR_ABORT_ON_LEAKED_HANDLES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ABORT_ON_LEAKED_HANDLES");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NOLOCAL, /* name */
        &MPIR_CVAR_NOLOCAL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "NODEMAP", /* category */
        "If true, force all processes to operate as though all processes are located on another node.  For example, this disables shared memory communication hierarchical collectives.");
    rc = MPL_env2bool("MPICH_NO_LOCAL", &(MPIR_CVAR_NOLOCAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NO_LOCAL");
    rc = MPL_env2bool("MPIR_PARAM_NO_LOCAL", &(MPIR_CVAR_NOLOCAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NO_LOCAL");
    rc = MPL_env2bool("MPIR_CVAR_NO_LOCAL", &(MPIR_CVAR_NOLOCAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NO_LOCAL");
    rc = MPL_env2bool("MPICH_NOLOCAL", &(MPIR_CVAR_NOLOCAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NOLOCAL");
    rc = MPL_env2bool("MPIR_PARAM_NOLOCAL", &(MPIR_CVAR_NOLOCAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NOLOCAL");
    rc = MPL_env2bool("MPIR_CVAR_NOLOCAL", &(MPIR_CVAR_NOLOCAL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NOLOCAL");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ODD_EVEN_CLIQUES, /* name */
        &MPIR_CVAR_ODD_EVEN_CLIQUES, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "NODEMAP", /* category */
        "If true, odd procs on a node are seen as local to each other, and even procs on a node are seen as local to each other.  Used for debugging on a single machine. Deprecated in favor of MPIR_CVAR_NUM_CLIQUES.");
    rc = MPL_env2bool("MPICH_EVEN_ODD_CLIQUES", &(MPIR_CVAR_ODD_EVEN_CLIQUES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_EVEN_ODD_CLIQUES");
    rc = MPL_env2bool("MPIR_PARAM_EVEN_ODD_CLIQUES", &(MPIR_CVAR_ODD_EVEN_CLIQUES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_EVEN_ODD_CLIQUES");
    rc = MPL_env2bool("MPIR_CVAR_EVEN_ODD_CLIQUES", &(MPIR_CVAR_ODD_EVEN_CLIQUES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_EVEN_ODD_CLIQUES");
    rc = MPL_env2bool("MPICH_ODD_EVEN_CLIQUES", &(MPIR_CVAR_ODD_EVEN_CLIQUES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ODD_EVEN_CLIQUES");
    rc = MPL_env2bool("MPIR_PARAM_ODD_EVEN_CLIQUES", &(MPIR_CVAR_ODD_EVEN_CLIQUES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ODD_EVEN_CLIQUES");
    rc = MPL_env2bool("MPIR_CVAR_ODD_EVEN_CLIQUES", &(MPIR_CVAR_ODD_EVEN_CLIQUES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ODD_EVEN_CLIQUES");

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NUM_CLIQUES, /* name */
        &MPIR_CVAR_NUM_CLIQUES, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "NODEMAP", /* category */
        "Specify the number of cliques that should be used to partition procs on a local node. Procs with the same clique number are seen as local to each other. Used for debugging on a single machine.");
    rc = MPL_env2int("MPICH_NUM_CLIQUES", &(MPIR_CVAR_NUM_CLIQUES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NUM_CLIQUES");
    rc = MPL_env2int("MPIR_PARAM_NUM_CLIQUES", &(MPIR_CVAR_NUM_CLIQUES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NUM_CLIQUES");
    rc = MPL_env2int("MPIR_CVAR_NUM_CLIQUES", &(MPIR_CVAR_NUM_CLIQUES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NUM_CLIQUES");
    rc = MPL_env2int("MPICH_NUM_CLIQUES", &(MPIR_CVAR_NUM_CLIQUES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NUM_CLIQUES");
    rc = MPL_env2int("MPIR_PARAM_NUM_CLIQUES", &(MPIR_CVAR_NUM_CLIQUES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NUM_CLIQUES");
    rc = MPL_env2int("MPIR_CVAR_NUM_CLIQUES", &(MPIR_CVAR_NUM_CLIQUES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NUM_CLIQUES");

    defaultval.d = 8;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_REQUEST_POLL_FREQ, /* name */
        &MPIR_CVAR_REQUEST_POLL_FREQ, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "REQUEST", /* category */
        "How frequent to poll during completion calls (wait/test) in terms of number of processed requests before polling.");
    rc = MPL_env2int("MPICH_REQUEST_POLL_FREQ", &(MPIR_CVAR_REQUEST_POLL_FREQ));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REQUEST_POLL_FREQ");
    rc = MPL_env2int("MPIR_PARAM_REQUEST_POLL_FREQ", &(MPIR_CVAR_REQUEST_POLL_FREQ));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REQUEST_POLL_FREQ");
    rc = MPL_env2int("MPIR_CVAR_REQUEST_POLL_FREQ", &(MPIR_CVAR_REQUEST_POLL_FREQ));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REQUEST_POLL_FREQ");

    defaultval.d = 64;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_REQUEST_BATCH_SIZE, /* name */
        &MPIR_CVAR_REQUEST_BATCH_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "REQUEST", /* category */
        "The number of requests to make completion as a batch in MPI_Waitall and MPI_Testall implementation. A large number is likely to cause more cache misses.");
    rc = MPL_env2int("MPICH_REQUEST_BATCH_SIZE", &(MPIR_CVAR_REQUEST_BATCH_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_REQUEST_BATCH_SIZE");
    rc = MPL_env2int("MPIR_PARAM_REQUEST_BATCH_SIZE", &(MPIR_CVAR_REQUEST_BATCH_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_REQUEST_BATCH_SIZE");
    rc = MPL_env2int("MPIR_CVAR_REQUEST_BATCH_SIZE", &(MPIR_CVAR_REQUEST_BATCH_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_REQUEST_BATCH_SIZE");

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_COLL_ALIAS_CHECK, /* name */
        &MPIR_CVAR_COLL_ALIAS_CHECK, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Enable checking of aliasing in collective operations");
    rc = MPL_env2int("MPICH_COLL_ALIAS_CHECK", &(MPIR_CVAR_COLL_ALIAS_CHECK));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_COLL_ALIAS_CHECK");
    rc = MPL_env2int("MPIR_PARAM_COLL_ALIAS_CHECK", &(MPIR_CVAR_COLL_ALIAS_CHECK));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_COLL_ALIAS_CHECK");
    rc = MPL_env2int("MPIR_CVAR_COLL_ALIAS_CHECK", &(MPIR_CVAR_COLL_ALIAS_CHECK));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_COLL_ALIAS_CHECK");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_CAPABILITY_SETS_DEBUG, /* name */
        &MPIR_CVAR_CH4_OFI_CAPABILITY_SETS_DEBUG, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "Prints out the configuration of each capability selected via the capability sets interface.");
    rc = MPL_env2int("MPICH_CH4_OFI_CAPABILITY_SETS_DEBUG", &(MPIR_CVAR_CH4_OFI_CAPABILITY_SETS_DEBUG));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_CAPABILITY_SETS_DEBUG");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_CAPABILITY_SETS_DEBUG", &(MPIR_CVAR_CH4_OFI_CAPABILITY_SETS_DEBUG));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_CAPABILITY_SETS_DEBUG");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_CAPABILITY_SETS_DEBUG", &(MPIR_CVAR_CH4_OFI_CAPABILITY_SETS_DEBUG));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_CAPABILITY_SETS_DEBUG");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_ENABLE_DATA, /* name */
        &MPIR_CVAR_CH4_OFI_ENABLE_DATA, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "Enable immediate data fields in OFI to transmit source rank outside of the match bits");
    rc = MPL_env2int("MPICH_CH4_OFI_ENABLE_DATA", &(MPIR_CVAR_CH4_OFI_ENABLE_DATA));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_ENABLE_DATA");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_ENABLE_DATA", &(MPIR_CVAR_CH4_OFI_ENABLE_DATA));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_ENABLE_DATA");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_ENABLE_DATA", &(MPIR_CVAR_CH4_OFI_ENABLE_DATA));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_ENABLE_DATA");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_ENABLE_AV_TABLE, /* name */
        &MPIR_CVAR_CH4_OFI_ENABLE_AV_TABLE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If true, the OFI addressing information will be stored with an FI_AV_TABLE. If false, an FI_AV_MAP will be used.");
    rc = MPL_env2int("MPICH_CH4_OFI_ENABLE_AV_TABLE", &(MPIR_CVAR_CH4_OFI_ENABLE_AV_TABLE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_ENABLE_AV_TABLE");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_ENABLE_AV_TABLE", &(MPIR_CVAR_CH4_OFI_ENABLE_AV_TABLE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_ENABLE_AV_TABLE");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_ENABLE_AV_TABLE", &(MPIR_CVAR_CH4_OFI_ENABLE_AV_TABLE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_ENABLE_AV_TABLE");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS, /* name */
        &MPIR_CVAR_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If true, use OFI scalable endpoints.");
    rc = MPL_env2int("MPICH_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS", &(MPIR_CVAR_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS", &(MPIR_CVAR_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS", &(MPIR_CVAR_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_ENABLE_SCALABLE_ENDPOINTS");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_ENABLE_SHARED_CONTEXTS, /* name */
        &MPIR_CVAR_CH4_OFI_ENABLE_SHARED_CONTEXTS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If set to false (zero), MPICH does not use OFI shared contexts. If set to -1, it is determined by the OFI capability sets based on the provider. Otherwise, MPICH tries to use OFI shared contexts. If they are unavailable, it'll fall back to the mode without shared contexts.");
    rc = MPL_env2int("MPICH_CH4_OFI_ENABLE_SHARED_CONTEXTS", &(MPIR_CVAR_CH4_OFI_ENABLE_SHARED_CONTEXTS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_ENABLE_SHARED_CONTEXTS");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_ENABLE_SHARED_CONTEXTS", &(MPIR_CVAR_CH4_OFI_ENABLE_SHARED_CONTEXTS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_ENABLE_SHARED_CONTEXTS");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_ENABLE_SHARED_CONTEXTS", &(MPIR_CVAR_CH4_OFI_ENABLE_SHARED_CONTEXTS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_ENABLE_SHARED_CONTEXTS");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_ENABLE_MR_SCALABLE, /* name */
        &MPIR_CVAR_CH4_OFI_ENABLE_MR_SCALABLE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If true, MR_SCALABLE for OFI memory regions. If false, MR_BASIC for OFI memory regions.");
    rc = MPL_env2int("MPICH_CH4_OFI_ENABLE_MR_SCALABLE", &(MPIR_CVAR_CH4_OFI_ENABLE_MR_SCALABLE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_ENABLE_MR_SCALABLE");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_ENABLE_MR_SCALABLE", &(MPIR_CVAR_CH4_OFI_ENABLE_MR_SCALABLE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_ENABLE_MR_SCALABLE");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_ENABLE_MR_SCALABLE", &(MPIR_CVAR_CH4_OFI_ENABLE_MR_SCALABLE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_ENABLE_MR_SCALABLE");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_ENABLE_TAGGED, /* name */
        &MPIR_CVAR_CH4_OFI_ENABLE_TAGGED, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If true, use tagged message transmission functions in OFI.");
    rc = MPL_env2int("MPICH_CH4_OFI_ENABLE_TAGGED", &(MPIR_CVAR_CH4_OFI_ENABLE_TAGGED));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_ENABLE_TAGGED");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_ENABLE_TAGGED", &(MPIR_CVAR_CH4_OFI_ENABLE_TAGGED));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_ENABLE_TAGGED");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_ENABLE_TAGGED", &(MPIR_CVAR_CH4_OFI_ENABLE_TAGGED));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_ENABLE_TAGGED");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_ENABLE_AM, /* name */
        &MPIR_CVAR_CH4_OFI_ENABLE_AM, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If true, enable OFI active message support.");
    rc = MPL_env2int("MPICH_CH4_OFI_ENABLE_AM", &(MPIR_CVAR_CH4_OFI_ENABLE_AM));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_ENABLE_AM");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_ENABLE_AM", &(MPIR_CVAR_CH4_OFI_ENABLE_AM));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_ENABLE_AM");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_ENABLE_AM", &(MPIR_CVAR_CH4_OFI_ENABLE_AM));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_ENABLE_AM");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_ENABLE_RMA, /* name */
        &MPIR_CVAR_CH4_OFI_ENABLE_RMA, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If true, enable OFI RMA support.");
    rc = MPL_env2int("MPICH_CH4_OFI_ENABLE_RMA", &(MPIR_CVAR_CH4_OFI_ENABLE_RMA));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_ENABLE_RMA");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_ENABLE_RMA", &(MPIR_CVAR_CH4_OFI_ENABLE_RMA));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_ENABLE_RMA");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_ENABLE_RMA", &(MPIR_CVAR_CH4_OFI_ENABLE_RMA));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_ENABLE_RMA");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_ENABLE_ATOMICS, /* name */
        &MPIR_CVAR_CH4_OFI_ENABLE_ATOMICS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If true, enable OFI Atomics support.");
    rc = MPL_env2int("MPICH_CH4_OFI_ENABLE_ATOMICS", &(MPIR_CVAR_CH4_OFI_ENABLE_ATOMICS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_ENABLE_ATOMICS");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_ENABLE_ATOMICS", &(MPIR_CVAR_CH4_OFI_ENABLE_ATOMICS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_ENABLE_ATOMICS");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_ENABLE_ATOMICS", &(MPIR_CVAR_CH4_OFI_ENABLE_ATOMICS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_ENABLE_ATOMICS");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_FETCH_ATOMIC_IOVECS, /* name */
        &MPIR_CVAR_CH4_OFI_FETCH_ATOMIC_IOVECS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "Specifies the maximum number of iovecs that can be used by the OFI provider for fetch_atomic operations. The default value is -1, indicating that no value is set.");
    rc = MPL_env2int("MPICH_CH4_OFI_FETCH_ATOMIC_IOVECS", &(MPIR_CVAR_CH4_OFI_FETCH_ATOMIC_IOVECS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_FETCH_ATOMIC_IOVECS");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_FETCH_ATOMIC_IOVECS", &(MPIR_CVAR_CH4_OFI_FETCH_ATOMIC_IOVECS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_FETCH_ATOMIC_IOVECS");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_FETCH_ATOMIC_IOVECS", &(MPIR_CVAR_CH4_OFI_FETCH_ATOMIC_IOVECS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_FETCH_ATOMIC_IOVECS");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS, /* name */
        &MPIR_CVAR_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If true, enable MPI data auto progress.");
    rc = MPL_env2int("MPICH_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS", &(MPIR_CVAR_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS", &(MPIR_CVAR_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS", &(MPIR_CVAR_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_ENABLE_DATA_AUTO_PROGRESS");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS, /* name */
        &MPIR_CVAR_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If true, enable MPI control auto progress.");
    rc = MPL_env2int("MPICH_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS", &(MPIR_CVAR_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS", &(MPIR_CVAR_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS", &(MPIR_CVAR_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_ENABLE_CONTROL_AUTO_PROGRESS");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_ENABLE_PT2PT_NOPACK, /* name */
        &MPIR_CVAR_CH4_OFI_ENABLE_PT2PT_NOPACK, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If true, enable iovec for pt2pt.");
    rc = MPL_env2int("MPICH_CH4_OFI_ENABLE_PT2PT_NOPACK", &(MPIR_CVAR_CH4_OFI_ENABLE_PT2PT_NOPACK));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_ENABLE_PT2PT_NOPACK");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_ENABLE_PT2PT_NOPACK", &(MPIR_CVAR_CH4_OFI_ENABLE_PT2PT_NOPACK));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_ENABLE_PT2PT_NOPACK");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_ENABLE_PT2PT_NOPACK", &(MPIR_CVAR_CH4_OFI_ENABLE_PT2PT_NOPACK));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_ENABLE_PT2PT_NOPACK");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_CONTEXT_ID_BITS, /* name */
        &MPIR_CVAR_CH4_OFI_CONTEXT_ID_BITS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "Specifies the number of bits that will be used for matching the context ID. The default value is -1, indicating that no value is set and that the default will be defined in the ofi_types.h file.");
    rc = MPL_env2int("MPICH_CH4_OFI_CONTEXT_ID_BITS", &(MPIR_CVAR_CH4_OFI_CONTEXT_ID_BITS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_CONTEXT_ID_BITS");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_CONTEXT_ID_BITS", &(MPIR_CVAR_CH4_OFI_CONTEXT_ID_BITS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_CONTEXT_ID_BITS");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_CONTEXT_ID_BITS", &(MPIR_CVAR_CH4_OFI_CONTEXT_ID_BITS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_CONTEXT_ID_BITS");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_RANK_BITS, /* name */
        &MPIR_CVAR_CH4_OFI_RANK_BITS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "Specifies the number of bits that will be used for matching the MPI rank. The default value is -1, indicating that no value is set and that the default will be defined in the ofi_types.h file.");
    rc = MPL_env2int("MPICH_CH4_OFI_RANK_BITS", &(MPIR_CVAR_CH4_OFI_RANK_BITS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_RANK_BITS");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_RANK_BITS", &(MPIR_CVAR_CH4_OFI_RANK_BITS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_RANK_BITS");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_RANK_BITS", &(MPIR_CVAR_CH4_OFI_RANK_BITS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_RANK_BITS");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_TAG_BITS, /* name */
        &MPIR_CVAR_CH4_OFI_TAG_BITS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "Specifies the number of bits that will be used for matching the user tag. The default value is -1, indicating that no value is set and that the default will be defined in the ofi_types.h file.");
    rc = MPL_env2int("MPICH_CH4_OFI_TAG_BITS", &(MPIR_CVAR_CH4_OFI_TAG_BITS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_TAG_BITS");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_TAG_BITS", &(MPIR_CVAR_CH4_OFI_TAG_BITS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_TAG_BITS");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_TAG_BITS", &(MPIR_CVAR_CH4_OFI_TAG_BITS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_TAG_BITS");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_MAJOR_VERSION, /* name */
        &MPIR_CVAR_CH4_OFI_MAJOR_VERSION, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "Specifies the major version of the OFI library. The default is the major version of the OFI library used with MPICH. If using this CVAR, it is recommended that the user also specifies a specific OFI provider.");
    rc = MPL_env2int("MPICH_CH4_OFI_MAJOR_VERSION", &(MPIR_CVAR_CH4_OFI_MAJOR_VERSION));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_MAJOR_VERSION");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_MAJOR_VERSION", &(MPIR_CVAR_CH4_OFI_MAJOR_VERSION));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_MAJOR_VERSION");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_MAJOR_VERSION", &(MPIR_CVAR_CH4_OFI_MAJOR_VERSION));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_MAJOR_VERSION");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_MINOR_VERSION, /* name */
        &MPIR_CVAR_CH4_OFI_MINOR_VERSION, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "Specifies the major version of the OFI library. The default is the minor version of the OFI library used with MPICH. If using this CVAR, it is recommended that the user also specifies a specific OFI provider.");
    rc = MPL_env2int("MPICH_CH4_OFI_MINOR_VERSION", &(MPIR_CVAR_CH4_OFI_MINOR_VERSION));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_MINOR_VERSION");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_MINOR_VERSION", &(MPIR_CVAR_CH4_OFI_MINOR_VERSION));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_MINOR_VERSION");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_MINOR_VERSION", &(MPIR_CVAR_CH4_OFI_MINOR_VERSION));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_MINOR_VERSION");

    defaultval.d = 1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_MAX_VNIS, /* name */
        &MPIR_CVAR_CH4_OFI_MAX_VNIS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If set to positive, this CVAR specifies the maximum number of CH4 VNIs that OFI netmod exposes.");
    rc = MPL_env2int("MPICH_CH4_OFI_MAX_VNIS", &(MPIR_CVAR_CH4_OFI_MAX_VNIS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_MAX_VNIS");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_MAX_VNIS", &(MPIR_CVAR_CH4_OFI_MAX_VNIS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_MAX_VNIS");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_MAX_VNIS", &(MPIR_CVAR_CH4_OFI_MAX_VNIS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_MAX_VNIS");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_MAX_RMA_SEP_CTX, /* name */
        &MPIR_CVAR_CH4_OFI_MAX_RMA_SEP_CTX, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If set to positive, this CVAR specifies the maximum number of transmit contexts RMA can utilize in a scalable endpoint. This value is effective only when scalable endpoint is available, otherwise it will be ignored.");
    rc = MPL_env2int("MPICH_CH4_OFI_MAX_RMA_SEP_CTX", &(MPIR_CVAR_CH4_OFI_MAX_RMA_SEP_CTX));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_MAX_RMA_SEP_CTX");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_MAX_RMA_SEP_CTX", &(MPIR_CVAR_CH4_OFI_MAX_RMA_SEP_CTX));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_MAX_RMA_SEP_CTX");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_MAX_RMA_SEP_CTX", &(MPIR_CVAR_CH4_OFI_MAX_RMA_SEP_CTX));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_MAX_RMA_SEP_CTX");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_MAX_EAGAIN_RETRY, /* name */
        &MPIR_CVAR_CH4_OFI_MAX_EAGAIN_RETRY, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "If set to positive, this CVAR specifies the maximum number of retries of an ofi operations before returning MPIX_ERR_EAGAIN. This value is effective only when the communicator has the MPI_OFI_set_eagain info hint set to true.");
    rc = MPL_env2int("MPICH_CH4_OFI_MAX_EAGAIN_RETRY", &(MPIR_CVAR_CH4_OFI_MAX_EAGAIN_RETRY));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_MAX_EAGAIN_RETRY");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_MAX_EAGAIN_RETRY", &(MPIR_CVAR_CH4_OFI_MAX_EAGAIN_RETRY));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_MAX_EAGAIN_RETRY");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_MAX_EAGAIN_RETRY", &(MPIR_CVAR_CH4_OFI_MAX_EAGAIN_RETRY));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_MAX_EAGAIN_RETRY");

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_OFI_NUM_AM_BUFFERS, /* name */
        &MPIR_CVAR_CH4_OFI_NUM_AM_BUFFERS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4_OFI", /* category */
        "Specifies the number of buffers for receiving active messages.");
    rc = MPL_env2int("MPICH_CH4_OFI_NUM_AM_BUFFERS", &(MPIR_CVAR_CH4_OFI_NUM_AM_BUFFERS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_OFI_NUM_AM_BUFFERS");
    rc = MPL_env2int("MPIR_PARAM_CH4_OFI_NUM_AM_BUFFERS", &(MPIR_CVAR_CH4_OFI_NUM_AM_BUFFERS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_OFI_NUM_AM_BUFFERS");
    rc = MPL_env2int("MPIR_CVAR_CH4_OFI_NUM_AM_BUFFERS", &(MPIR_CVAR_CH4_OFI_NUM_AM_BUFFERS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_OFI_NUM_AM_BUFFERS");

    defaultval.d = 180;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_COMM_CONNECT_TIMEOUT, /* name */
        &MPIR_CVAR_CH4_COMM_CONNECT_TIMEOUT, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_GROUP_EQ,
        defaultval,
        "CH4", /* category */
        "The default time out period in seconds for a connection attempt to the server communicator where the named port exists but no pending accept. User can change the value for a specified connection through its info argument.");
    rc = MPL_env2int("MPICH_CH4_COMM_CONNECT_TIMEOUT", &(MPIR_CVAR_CH4_COMM_CONNECT_TIMEOUT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_COMM_CONNECT_TIMEOUT");
    rc = MPL_env2int("MPIR_PARAM_CH4_COMM_CONNECT_TIMEOUT", &(MPIR_CVAR_CH4_COMM_CONNECT_TIMEOUT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_COMM_CONNECT_TIMEOUT");
    rc = MPL_env2int("MPIR_CVAR_CH4_COMM_CONNECT_TIMEOUT", &(MPIR_CVAR_CH4_COMM_CONNECT_TIMEOUT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_COMM_CONNECT_TIMEOUT");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_RMA_MEM_EFFICIENT, /* name */
        &MPIR_CVAR_CH4_RMA_MEM_EFFICIENT, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_GROUP_EQ,
        defaultval,
        "CH4", /* category */
        "If true, memory-saving mode is on, per-target object is released at the epoch end call. If false, performance-efficient mode is on, all allocated target objects are cached and freed at win_finalize.");
    rc = MPL_env2bool("MPICH_CH4_RMA_MEM_EFFICIENT", &(MPIR_CVAR_CH4_RMA_MEM_EFFICIENT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_RMA_MEM_EFFICIENT");
    rc = MPL_env2bool("MPIR_PARAM_CH4_RMA_MEM_EFFICIENT", &(MPIR_CVAR_CH4_RMA_MEM_EFFICIENT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_RMA_MEM_EFFICIENT");
    rc = MPL_env2bool("MPIR_CVAR_CH4_RMA_MEM_EFFICIENT", &(MPIR_CVAR_CH4_RMA_MEM_EFFICIENT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_RMA_MEM_EFFICIENT");

    defaultval.str = (char *)"";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_CH4_NETMOD, /* name */
        &MPIR_CVAR_CH4_NETMOD, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH4", /* category */
        "If non-empty, this cvar specifies which network module to use");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_CH4_NETMOD, &tmp_str);
    rc = MPL_env2str("MPICH_CH4_NETMOD", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_NETMOD");
    rc = MPL_env2str("MPIR_PARAM_CH4_NETMOD", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_NETMOD");
    rc = MPL_env2str("MPIR_CVAR_CH4_NETMOD", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_NETMOD");
    if (tmp_str != NULL) {
        MPIR_CVAR_CH4_NETMOD = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_CH4_NETMOD);
        if (MPIR_CVAR_CH4_NETMOD == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_CH4_NETMOD");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_CH4_NETMOD = NULL;
    }

    defaultval.str = (char *)"";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_CH4_SHM, /* name */
        &MPIR_CVAR_CH4_SHM, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH4", /* category */
        "If non-empty, this cvar specifies which shm module to use");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_CH4_SHM, &tmp_str);
    rc = MPL_env2str("MPICH_CH4_SHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_SHM");
    rc = MPL_env2str("MPIR_PARAM_CH4_SHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_SHM");
    rc = MPL_env2str("MPIR_CVAR_CH4_SHM", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_SHM");
    if (tmp_str != NULL) {
        MPIR_CVAR_CH4_SHM = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_CH4_SHM);
        if (MPIR_CVAR_CH4_SHM == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_CH4_SHM");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_CH4_SHM = NULL;
    }

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_ROOTS_ONLY_PMI, /* name */
        &MPIR_CVAR_CH4_ROOTS_ONLY_PMI, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH4", /* category */
        "Enables an optimized business card exchange over PMI for node root processes only.");
    rc = MPL_env2bool("MPICH_CH4_ROOTS_ONLY_PMI", &(MPIR_CVAR_CH4_ROOTS_ONLY_PMI));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_ROOTS_ONLY_PMI");
    rc = MPL_env2bool("MPIR_PARAM_CH4_ROOTS_ONLY_PMI", &(MPIR_CVAR_CH4_ROOTS_ONLY_PMI));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_ROOTS_ONLY_PMI");
    rc = MPL_env2bool("MPIR_CVAR_CH4_ROOTS_ONLY_PMI", &(MPIR_CVAR_CH4_ROOTS_ONLY_PMI));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_ROOTS_ONLY_PMI");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_RUNTIME_CONF_DEBUG, /* name */
        &MPIR_CVAR_CH4_RUNTIME_CONF_DEBUG, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH4", /* category */
        "If enabled, CH4-level runtime configurations are printed out");
    rc = MPL_env2bool("MPICH_CH4_RUNTIME_CONF_DEBUG", &(MPIR_CVAR_CH4_RUNTIME_CONF_DEBUG));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_RUNTIME_CONF_DEBUG");
    rc = MPL_env2bool("MPIR_PARAM_CH4_RUNTIME_CONF_DEBUG", &(MPIR_CVAR_CH4_RUNTIME_CONF_DEBUG));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_RUNTIME_CONF_DEBUG");
    rc = MPL_env2bool("MPIR_CVAR_CH4_RUNTIME_CONF_DEBUG", &(MPIR_CVAR_CH4_RUNTIME_CONF_DEBUG));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_RUNTIME_CONF_DEBUG");

    defaultval.str = (char *)"";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_CH4_MT_MODEL, /* name */
        &MPIR_CVAR_CH4_MT_MODEL, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH4", /* category */
        "Specifies the CH4 multi-threading model. Possible values are: direct (default) handoff trylock");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_CH4_MT_MODEL, &tmp_str);
    rc = MPL_env2str("MPICH_CH4_MT_MODEL", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_MT_MODEL");
    rc = MPL_env2str("MPIR_PARAM_CH4_MT_MODEL", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_MT_MODEL");
    rc = MPL_env2str("MPIR_CVAR_CH4_MT_MODEL", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_MT_MODEL");
    if (tmp_str != NULL) {
        MPIR_CVAR_CH4_MT_MODEL = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_CH4_MT_MODEL);
        if (MPIR_CVAR_CH4_MT_MODEL == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_CH4_MT_MODEL");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_CH4_MT_MODEL = NULL;
    }

    defaultval.d = 100;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_RANDOM_ADDR_RETRY, /* name */
        &MPIR_CVAR_CH4_RANDOM_ADDR_RETRY, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_GROUP,
        defaultval,
        "CH4", /* category */
        "The default number of retries for generating a random address. A retrying involves only local operations.");
    rc = MPL_env2int("MPICH_CH4_RANDOM_ADDR_RETRY", &(MPIR_CVAR_CH4_RANDOM_ADDR_RETRY));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_RANDOM_ADDR_RETRY");
    rc = MPL_env2int("MPIR_PARAM_CH4_RANDOM_ADDR_RETRY", &(MPIR_CVAR_CH4_RANDOM_ADDR_RETRY));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_RANDOM_ADDR_RETRY");
    rc = MPL_env2int("MPIR_CVAR_CH4_RANDOM_ADDR_RETRY", &(MPIR_CVAR_CH4_RANDOM_ADDR_RETRY));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_RANDOM_ADDR_RETRY");

    defaultval.d = 100;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH4_SHM_SYMHEAP_RETRY, /* name */
        &MPIR_CVAR_CH4_SHM_SYMHEAP_RETRY, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_GROUP,
        defaultval,
        "CH4", /* category */
        "The default number of retries for allocating a symmetric heap in shared memory. A retrying involves collective communication over the group in the shared memory.");
    rc = MPL_env2int("MPICH_CH4_SHM_SYMHEAP_RETRY", &(MPIR_CVAR_CH4_SHM_SYMHEAP_RETRY));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH4_SHM_SYMHEAP_RETRY");
    rc = MPL_env2int("MPIR_PARAM_CH4_SHM_SYMHEAP_RETRY", &(MPIR_CVAR_CH4_SHM_SYMHEAP_RETRY));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH4_SHM_SYMHEAP_RETRY");
    rc = MPL_env2int("MPIR_CVAR_CH4_SHM_SYMHEAP_RETRY", &(MPIR_CVAR_CH4_SHM_SYMHEAP_RETRY));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH4_SHM_SYMHEAP_RETRY");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ENABLE_HCOLL, /* name */
        &MPIR_CVAR_ENABLE_HCOLL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "COLLECTIVE", /* category */
        "Enable hcoll collective support.");
    rc = MPL_env2bool("MPICH_ENABLE_HCOLL", &(MPIR_CVAR_ENABLE_HCOLL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ENABLE_HCOLL");
    rc = MPL_env2bool("MPIR_PARAM_ENABLE_HCOLL", &(MPIR_CVAR_ENABLE_HCOLL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ENABLE_HCOLL");
    rc = MPL_env2bool("MPIR_CVAR_ENABLE_HCOLL", &(MPIR_CVAR_ENABLE_HCOLL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ENABLE_HCOLL");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_COLL_SCHED_DUMP, /* name */
        &MPIR_CVAR_COLL_SCHED_DUMP, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "COLLECTIVE", /* category */
        "Print schedule data for nonblocking collective operations.");
    rc = MPL_env2bool("MPICH_COLL_SCHED_DUMP", &(MPIR_CVAR_COLL_SCHED_DUMP));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_COLL_SCHED_DUMP");
    rc = MPL_env2bool("MPIR_PARAM_COLL_SCHED_DUMP", &(MPIR_CVAR_COLL_SCHED_DUMP));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_COLL_SCHED_DUMP");
    rc = MPL_env2bool("MPIR_CVAR_COLL_SCHED_DUMP", &(MPIR_CVAR_COLL_SCHED_DUMP));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_COLL_SCHED_DUMP");

    defaultval.str = (char *)NULL;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_OFI_USE_PROVIDER, /* name */
        &MPIR_CVAR_OFI_USE_PROVIDER, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_MPIDEV_DETAIL,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "DEVELOPER", /* category */
        "If non-null, choose an OFI provider by name. If using with the CH4 device and using a provider that supports an older version of the libfabric API then the default version of the installed library, specifying the OFI version via the appropriate CVARs is also recommended.");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_OFI_USE_PROVIDER, &tmp_str);
    rc = MPL_env2str("MPICH_OFI_USE_PROVIDER", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_OFI_USE_PROVIDER");
    rc = MPL_env2str("MPIR_PARAM_OFI_USE_PROVIDER", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_OFI_USE_PROVIDER");
    rc = MPL_env2str("MPIR_CVAR_OFI_USE_PROVIDER", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_OFI_USE_PROVIDER");
    if (tmp_str != NULL) {
        MPIR_CVAR_OFI_USE_PROVIDER = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_OFI_USE_PROVIDER);
        if (MPIR_CVAR_OFI_USE_PROVIDER == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_OFI_USE_PROVIDER");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_OFI_USE_PROVIDER = NULL;
    }

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_OFI_DUMP_PROVIDERS, /* name */
        &MPIR_CVAR_OFI_DUMP_PROVIDERS, /* address */
        1, /* count */
        MPI_T_VERBOSITY_MPIDEV_DETAIL,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "DEVELOPER", /* category */
        "If true, dump provider information at init");
    rc = MPL_env2bool("MPICH_OFI_DUMP_PROVIDERS", &(MPIR_CVAR_OFI_DUMP_PROVIDERS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_OFI_DUMP_PROVIDERS");
    rc = MPL_env2bool("MPIR_PARAM_OFI_DUMP_PROVIDERS", &(MPIR_CVAR_OFI_DUMP_PROVIDERS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_OFI_DUMP_PROVIDERS");
    rc = MPL_env2bool("MPIR_CVAR_OFI_DUMP_PROVIDERS", &(MPIR_CVAR_OFI_DUMP_PROVIDERS));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_OFI_DUMP_PROVIDERS");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEMESIS_MXM_BULK_CONNECT, /* name */
        &MPIR_CVAR_NEMESIS_MXM_BULK_CONNECT, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "If true, force mxm to connect all processes at initialization time.");
    rc = MPL_env2bool("MPICH_NEMESIS_MXM_BULK_CONNECT", &(MPIR_CVAR_NEMESIS_MXM_BULK_CONNECT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEMESIS_MXM_BULK_CONNECT");
    rc = MPL_env2bool("MPIR_PARAM_NEMESIS_MXM_BULK_CONNECT", &(MPIR_CVAR_NEMESIS_MXM_BULK_CONNECT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEMESIS_MXM_BULK_CONNECT");
    rc = MPL_env2bool("MPIR_CVAR_NEMESIS_MXM_BULK_CONNECT", &(MPIR_CVAR_NEMESIS_MXM_BULK_CONNECT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEMESIS_MXM_BULK_CONNECT");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEMESIS_MXM_BULK_DISCONNECT, /* name */
        &MPIR_CVAR_NEMESIS_MXM_BULK_DISCONNECT, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "If true, force mxm to disconnect all processes at finalization time.");
    rc = MPL_env2bool("MPICH_NEMESIS_MXM_BULK_DISCONNECT", &(MPIR_CVAR_NEMESIS_MXM_BULK_DISCONNECT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEMESIS_MXM_BULK_DISCONNECT");
    rc = MPL_env2bool("MPIR_PARAM_NEMESIS_MXM_BULK_DISCONNECT", &(MPIR_CVAR_NEMESIS_MXM_BULK_DISCONNECT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEMESIS_MXM_BULK_DISCONNECT");
    rc = MPL_env2bool("MPIR_CVAR_NEMESIS_MXM_BULK_DISCONNECT", &(MPIR_CVAR_NEMESIS_MXM_BULK_DISCONNECT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEMESIS_MXM_BULK_DISCONNECT");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEMESIS_MXM_HUGEPAGE, /* name */
        &MPIR_CVAR_NEMESIS_MXM_HUGEPAGE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "If true, mxm tries detecting hugepage support.  On HPC-X 2.3 and earlier, this might cause problems on Ubuntu and other platforms even if the system provides hugepage support.");
    rc = MPL_env2bool("MPICH_NEMESIS_MXM_HUGEPAGE", &(MPIR_CVAR_NEMESIS_MXM_HUGEPAGE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEMESIS_MXM_HUGEPAGE");
    rc = MPL_env2bool("MPIR_PARAM_NEMESIS_MXM_HUGEPAGE", &(MPIR_CVAR_NEMESIS_MXM_HUGEPAGE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEMESIS_MXM_HUGEPAGE");
    rc = MPL_env2bool("MPIR_CVAR_NEMESIS_MXM_HUGEPAGE", &(MPIR_CVAR_NEMESIS_MXM_HUGEPAGE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEMESIS_MXM_HUGEPAGE");

    defaultval.str = (char *)NULL;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_CH3_INTERFACE_HOSTNAME, /* name */
        &MPIR_CVAR_CH3_INTERFACE_HOSTNAME, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_LOCAL,
        defaultval,
        "CH3", /* category */
        "If non-NULL, this cvar specifies the IP address that other processes should use when connecting to this process. This cvar is mutually exclusive with the MPIR_CVAR_CH3_NETWORK_IFACE cvar and it is an error to set them both.");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_CH3_INTERFACE_HOSTNAME, &tmp_str);
    rc = MPL_env2str("MPICH_INTERFACE_HOSTNAME", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_INTERFACE_HOSTNAME");
    rc = MPL_env2str("MPIR_PARAM_INTERFACE_HOSTNAME", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_INTERFACE_HOSTNAME");
    rc = MPL_env2str("MPIR_CVAR_INTERFACE_HOSTNAME", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_INTERFACE_HOSTNAME");
    rc = MPL_env2str("MPICH_CH3_INTERFACE_HOSTNAME", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_INTERFACE_HOSTNAME");
    rc = MPL_env2str("MPIR_PARAM_CH3_INTERFACE_HOSTNAME", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_INTERFACE_HOSTNAME");
    rc = MPL_env2str("MPIR_CVAR_CH3_INTERFACE_HOSTNAME", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_INTERFACE_HOSTNAME");
    if (tmp_str != NULL) {
        MPIR_CVAR_CH3_INTERFACE_HOSTNAME = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_CH3_INTERFACE_HOSTNAME);
        if (MPIR_CVAR_CH3_INTERFACE_HOSTNAME == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_CH3_INTERFACE_HOSTNAME");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_CH3_INTERFACE_HOSTNAME = NULL;
    }

    {
        MPIR_T_cvar_range_value_t tmp = {0,0};
        defaultval.range = tmp;
    }
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_PORT_RANGE, /* name */
        &MPIR_CVAR_CH3_PORT_RANGE, /* address */
        2, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "The MPIR_CVAR_CH3_PORT_RANGE environment variable allows you to specify the range of TCP ports to be used by the process manager and the MPICH library. The format of this variable is <low>:<high>.  To specify any available port, use 0:0.");
    rc = MPL_env2range("MPICH_PORTRANGE", &(MPIR_CVAR_CH3_PORT_RANGE.low), &(MPIR_CVAR_CH3_PORT_RANGE.high));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_PORTRANGE");
    rc = MPL_env2range("MPICH_PORT_RANGE", &(MPIR_CVAR_CH3_PORT_RANGE.low), &(MPIR_CVAR_CH3_PORT_RANGE.high));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_PORT_RANGE");
    rc = MPL_env2range("MPIR_PARAM_PORTRANGE", &(MPIR_CVAR_CH3_PORT_RANGE.low), &(MPIR_CVAR_CH3_PORT_RANGE.high));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_PORTRANGE");
    rc = MPL_env2range("MPIR_PARAM_PORT_RANGE", &(MPIR_CVAR_CH3_PORT_RANGE.low), &(MPIR_CVAR_CH3_PORT_RANGE.high));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_PORT_RANGE");
    rc = MPL_env2range("MPIR_CVAR_PORTRANGE", &(MPIR_CVAR_CH3_PORT_RANGE.low), &(MPIR_CVAR_CH3_PORT_RANGE.high));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_PORTRANGE");
    rc = MPL_env2range("MPIR_CVAR_PORT_RANGE", &(MPIR_CVAR_CH3_PORT_RANGE.low), &(MPIR_CVAR_CH3_PORT_RANGE.high));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_PORT_RANGE");
    rc = MPL_env2range("MPICH_CH3_PORT_RANGE", &(MPIR_CVAR_CH3_PORT_RANGE.low), &(MPIR_CVAR_CH3_PORT_RANGE.high));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_PORT_RANGE");
    rc = MPL_env2range("MPIR_PARAM_CH3_PORT_RANGE", &(MPIR_CVAR_CH3_PORT_RANGE.low), &(MPIR_CVAR_CH3_PORT_RANGE.high));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_PORT_RANGE");
    rc = MPL_env2range("MPIR_CVAR_CH3_PORT_RANGE", &(MPIR_CVAR_CH3_PORT_RANGE.low), &(MPIR_CVAR_CH3_PORT_RANGE.high));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_PORT_RANGE");

    defaultval.str = (char *)NULL;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE, /* name */
        &MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "NEMESIS", /* category */
        "If non-NULL, this cvar specifies which pseudo-ethernet interface the tcp netmod should use (e.g., \"eth1\", \"ib0\"). Note, this is a Linux-specific cvar. This cvar is mutually exclusive with the MPIR_CVAR_CH3_INTERFACE_HOSTNAME cvar and it is an error to set them both.");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE, &tmp_str);
    rc = MPL_env2str("MPICH_NETWORK_IFACE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NETWORK_IFACE");
    rc = MPL_env2str("MPIR_PARAM_NETWORK_IFACE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NETWORK_IFACE");
    rc = MPL_env2str("MPIR_CVAR_NETWORK_IFACE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NETWORK_IFACE");
    rc = MPL_env2str("MPICH_NEMESIS_TCP_NETWORK_IFACE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEMESIS_TCP_NETWORK_IFACE");
    rc = MPL_env2str("MPIR_PARAM_NEMESIS_TCP_NETWORK_IFACE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEMESIS_TCP_NETWORK_IFACE");
    rc = MPL_env2str("MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE");
    if (tmp_str != NULL) {
        MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE);
        if (MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE = NULL;
    }

    defaultval.d = 10;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEMESIS_TCP_HOST_LOOKUP_RETRIES, /* name */
        &MPIR_CVAR_NEMESIS_TCP_HOST_LOOKUP_RETRIES, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "NEMESIS", /* category */
        "This cvar controls the number of times to retry the gethostbyname() function before giving up.");
    rc = MPL_env2int("MPICH_NEMESIS_TCP_HOST_LOOKUP_RETRIES", &(MPIR_CVAR_NEMESIS_TCP_HOST_LOOKUP_RETRIES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEMESIS_TCP_HOST_LOOKUP_RETRIES");
    rc = MPL_env2int("MPIR_PARAM_NEMESIS_TCP_HOST_LOOKUP_RETRIES", &(MPIR_CVAR_NEMESIS_TCP_HOST_LOOKUP_RETRIES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEMESIS_TCP_HOST_LOOKUP_RETRIES");
    rc = MPL_env2int("MPIR_CVAR_NEMESIS_TCP_HOST_LOOKUP_RETRIES", &(MPIR_CVAR_NEMESIS_TCP_HOST_LOOKUP_RETRIES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEMESIS_TCP_HOST_LOOKUP_RETRIES");

    defaultval.d = 1000;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_POLLS_BEFORE_YIELD, /* name */
        &MPIR_CVAR_POLLS_BEFORE_YIELD, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "NEMESIS", /* category */
        "When MPICH is in a busy waiting loop, it will periodically call a function to yield the processor.  This cvar sets the number of loops before the yield function is called.  A value of 0 disables yielding.");
    rc = MPL_env2int("MPICH_POLLS_BEFORE_YIELD", &(MPIR_CVAR_POLLS_BEFORE_YIELD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_POLLS_BEFORE_YIELD");
    rc = MPL_env2int("MPIR_PARAM_POLLS_BEFORE_YIELD", &(MPIR_CVAR_POLLS_BEFORE_YIELD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_POLLS_BEFORE_YIELD");
    rc = MPL_env2int("MPIR_CVAR_POLLS_BEFORE_YIELD", &(MPIR_CVAR_POLLS_BEFORE_YIELD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_POLLS_BEFORE_YIELD");

    defaultval.str = (char *)"";
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_CHAR,
        MPIR_CVAR_NEMESIS_NETMOD, /* name */
        &MPIR_CVAR_NEMESIS_NETMOD, /* address */
        MPIR_CVAR_MAX_STRLEN, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "NEMESIS", /* category */
        "If non-empty, this cvar specifies which network module should be used for communication. This variable is case-insensitive.");
    MPIR_CVAR_GET_DEFAULT_STRING(MPIR_CVAR_NEMESIS_NETMOD, &tmp_str);
    rc = MPL_env2str("MPICH_NEMESIS_NETMOD", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEMESIS_NETMOD");
    rc = MPL_env2str("MPIR_PARAM_NEMESIS_NETMOD", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEMESIS_NETMOD");
    rc = MPL_env2str("MPIR_CVAR_NEMESIS_NETMOD", &tmp_str);
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEMESIS_NETMOD");
    if (tmp_str != NULL) {
        MPIR_CVAR_NEMESIS_NETMOD = MPL_strdup(tmp_str);
        MPIR_CVAR_assert(MPIR_CVAR_NEMESIS_NETMOD);
        if (MPIR_CVAR_NEMESIS_NETMOD == NULL) {
            MPIR_CHKMEM_SETERR(mpi_errno, strlen(tmp_str), "dup of string for MPIR_CVAR_NEMESIS_NETMOD");
            goto fn_fail;
        }
    }
    else {
        MPIR_CVAR_NEMESIS_NETMOD = NULL;
    }

    defaultval.d = -1;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEMESIS_SHM_EAGER_MAX_SZ, /* name */
        &MPIR_CVAR_NEMESIS_SHM_EAGER_MAX_SZ, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "NEMESIS", /* category */
        "This cvar controls the message size at which Nemesis switches from eager to rendezvous mode for shared memory. If this cvar is set to -1, then Nemesis will choose an appropriate value.");
    rc = MPL_env2int("MPICH_NEMESIS_SHM_EAGER_MAX_SZ", &(MPIR_CVAR_NEMESIS_SHM_EAGER_MAX_SZ));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEMESIS_SHM_EAGER_MAX_SZ");
    rc = MPL_env2int("MPIR_PARAM_NEMESIS_SHM_EAGER_MAX_SZ", &(MPIR_CVAR_NEMESIS_SHM_EAGER_MAX_SZ));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEMESIS_SHM_EAGER_MAX_SZ");
    rc = MPL_env2int("MPIR_CVAR_NEMESIS_SHM_EAGER_MAX_SZ", &(MPIR_CVAR_NEMESIS_SHM_EAGER_MAX_SZ));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEMESIS_SHM_EAGER_MAX_SZ");

    defaultval.d = -2;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEMESIS_SHM_READY_EAGER_MAX_SZ, /* name */
        &MPIR_CVAR_NEMESIS_SHM_READY_EAGER_MAX_SZ, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "NEMESIS", /* category */
        "This cvar controls the message size at which Nemesis switches from eager to rendezvous mode for ready-send messages.  If this cvar is set to -1, then ready messages will always be sent eagerly.  If this cvar is set to -2, then Nemesis will choose an appropriate value.");
    rc = MPL_env2int("MPICH_NEMESIS_SHM_READY_EAGER_MAX_SZ", &(MPIR_CVAR_NEMESIS_SHM_READY_EAGER_MAX_SZ));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEMESIS_SHM_READY_EAGER_MAX_SZ");
    rc = MPL_env2int("MPIR_PARAM_NEMESIS_SHM_READY_EAGER_MAX_SZ", &(MPIR_CVAR_NEMESIS_SHM_READY_EAGER_MAX_SZ));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEMESIS_SHM_READY_EAGER_MAX_SZ");
    rc = MPL_env2int("MPIR_CVAR_NEMESIS_SHM_READY_EAGER_MAX_SZ", &(MPIR_CVAR_NEMESIS_SHM_READY_EAGER_MAX_SZ));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEMESIS_SHM_READY_EAGER_MAX_SZ");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEMESIS_ENABLE_CKPOINT, /* name */
        &MPIR_CVAR_NEMESIS_ENABLE_CKPOINT, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "NEMESIS", /* category */
        "If true, enables checkpointing support and returns an error if checkpointing library cannot be initialized.");
    rc = MPL_env2bool("MPICH_NEMESIS_ENABLE_CKPOINT", &(MPIR_CVAR_NEMESIS_ENABLE_CKPOINT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEMESIS_ENABLE_CKPOINT");
    rc = MPL_env2bool("MPIR_PARAM_NEMESIS_ENABLE_CKPOINT", &(MPIR_CVAR_NEMESIS_ENABLE_CKPOINT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEMESIS_ENABLE_CKPOINT");
    rc = MPL_env2bool("MPIR_CVAR_NEMESIS_ENABLE_CKPOINT", &(MPIR_CVAR_NEMESIS_ENABLE_CKPOINT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEMESIS_ENABLE_CKPOINT");

    defaultval.d = 2097152;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_NEMESIS_LMT_DMA_THRESHOLD, /* name */
        &MPIR_CVAR_NEMESIS_LMT_DMA_THRESHOLD, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "NEMESIS", /* category */
        "Messages larger than this size will use the \"dma\" (knem) intranode LMT implementation, if it is enabled and available.");
    rc = MPL_env2int("MPICH_NEMESIS_LMT_DMA_THRESHOLD", &(MPIR_CVAR_NEMESIS_LMT_DMA_THRESHOLD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_NEMESIS_LMT_DMA_THRESHOLD");
    rc = MPL_env2int("MPIR_PARAM_NEMESIS_LMT_DMA_THRESHOLD", &(MPIR_CVAR_NEMESIS_LMT_DMA_THRESHOLD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_NEMESIS_LMT_DMA_THRESHOLD");
    rc = MPL_env2int("MPIR_CVAR_NEMESIS_LMT_DMA_THRESHOLD", &(MPIR_CVAR_NEMESIS_LMT_DMA_THRESHOLD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_NEMESIS_LMT_DMA_THRESHOLD");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_ENABLE_FT, /* name */
        &MPIR_CVAR_ENABLE_FT, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "FT", /* category */
        "Enable fault tolerance functions");
    rc = MPL_env2bool("MPICH_ENABLE_FT", &(MPIR_CVAR_ENABLE_FT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_ENABLE_FT");
    rc = MPL_env2bool("MPIR_PARAM_ENABLE_FT", &(MPIR_CVAR_ENABLE_FT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_ENABLE_FT");
    rc = MPL_env2bool("MPIR_CVAR_ENABLE_FT", &(MPIR_CVAR_ENABLE_FT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_ENABLE_FT");

    defaultval.d = 1024;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_RMA_SCALABLE_FENCE_PROCESS_NUM, /* name */
        &MPIR_CVAR_CH3_RMA_SCALABLE_FENCE_PROCESS_NUM, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "Specify the threshold of switching the algorithm used in FENCE from the basic algorithm to the scalable algorithm. The value can be nagative, zero or positive. When the number of processes is larger than or equal to this value, FENCE will use a scalable algorithm which do not use O(P) data structure; when the number of processes is smaller than the value, FENCE will use a basic but fast algorithm which requires an O(P) data structure.");
    rc = MPL_env2int("MPICH_CH3_RMA_SCALABLE_FENCE_PROCESS_NUM", &(MPIR_CVAR_CH3_RMA_SCALABLE_FENCE_PROCESS_NUM));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_RMA_SCALABLE_FENCE_PROCESS_NUM");
    rc = MPL_env2int("MPIR_PARAM_CH3_RMA_SCALABLE_FENCE_PROCESS_NUM", &(MPIR_CVAR_CH3_RMA_SCALABLE_FENCE_PROCESS_NUM));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_RMA_SCALABLE_FENCE_PROCESS_NUM");
    rc = MPL_env2int("MPIR_CVAR_CH3_RMA_SCALABLE_FENCE_PROCESS_NUM", &(MPIR_CVAR_CH3_RMA_SCALABLE_FENCE_PROCESS_NUM));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_RMA_SCALABLE_FENCE_PROCESS_NUM");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_RMA_DELAY_ISSUING_FOR_PIGGYBACKING, /* name */
        &MPIR_CVAR_CH3_RMA_DELAY_ISSUING_FOR_PIGGYBACKING, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "Specify if delay issuing of RMA operations for piggybacking LOCK/UNLOCK/FLUSH is enabled. It can be either 0 or 1. When it is set to 1, the issuing of LOCK message is delayed until origin process see the first RMA operation and piggyback LOCK with that operation, and the origin process always keeps the current last operation until the ending synchronization call in order to piggyback UNLOCK/FLUSH with that operation. When it is set to 0, in WIN_LOCK/UNLOCK case, the LOCK message is sent out as early as possible, in WIN_LOCK_ALL/UNLOCK_ALL case, the origin process still tries to piggyback LOCK message with the first operation; for UNLOCK/FLUSH message, the origin process no longer keeps the current last operation but only piggyback UNLOCK/FLUSH if there is an operation avaliable in the ending synchronization call.");
    rc = MPL_env2int("MPICH_CH3_RMA_DELAY_ISSUING_FOR_PIGGYBACKING", &(MPIR_CVAR_CH3_RMA_DELAY_ISSUING_FOR_PIGGYBACKING));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_RMA_DELAY_ISSUING_FOR_PIGGYBACKING");
    rc = MPL_env2int("MPIR_PARAM_CH3_RMA_DELAY_ISSUING_FOR_PIGGYBACKING", &(MPIR_CVAR_CH3_RMA_DELAY_ISSUING_FOR_PIGGYBACKING));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_RMA_DELAY_ISSUING_FOR_PIGGYBACKING");
    rc = MPL_env2int("MPIR_CVAR_CH3_RMA_DELAY_ISSUING_FOR_PIGGYBACKING", &(MPIR_CVAR_CH3_RMA_DELAY_ISSUING_FOR_PIGGYBACKING));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_RMA_DELAY_ISSUING_FOR_PIGGYBACKING");

    defaultval.d = 131072;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_EAGER_MAX_MSG_SIZE, /* name */
        &MPIR_CVAR_CH3_EAGER_MAX_MSG_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "This cvar controls the message size at which CH3 switches from eager to rendezvous mode.");
    rc = MPL_env2int("MPICH_CH3_EAGER_MAX_MSG_SIZE", &(MPIR_CVAR_CH3_EAGER_MAX_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_EAGER_MAX_MSG_SIZE");
    rc = MPL_env2int("MPIR_PARAM_CH3_EAGER_MAX_MSG_SIZE", &(MPIR_CVAR_CH3_EAGER_MAX_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_EAGER_MAX_MSG_SIZE");
    rc = MPL_env2int("MPIR_CVAR_CH3_EAGER_MAX_MSG_SIZE", &(MPIR_CVAR_CH3_EAGER_MAX_MSG_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_EAGER_MAX_MSG_SIZE");

    defaultval.d = 262144;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_RMA_SLOTS_SIZE, /* name */
        &MPIR_CVAR_CH3_RMA_SLOTS_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "Number of RMA slots during window creation. Each slot contains a linked list of target elements. The distribution of ranks among slots follows a round-robin pattern. Requires a positive value.");
    rc = MPL_env2int("MPICH_CH3_RMA_SLOTS_SIZE", &(MPIR_CVAR_CH3_RMA_SLOTS_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_RMA_SLOTS_SIZE");
    rc = MPL_env2int("MPIR_PARAM_CH3_RMA_SLOTS_SIZE", &(MPIR_CVAR_CH3_RMA_SLOTS_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_RMA_SLOTS_SIZE");
    rc = MPL_env2int("MPIR_CVAR_CH3_RMA_SLOTS_SIZE", &(MPIR_CVAR_CH3_RMA_SLOTS_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_RMA_SLOTS_SIZE");

    defaultval.d = 655360;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_RMA_TARGET_LOCK_DATA_BYTES, /* name */
        &MPIR_CVAR_CH3_RMA_TARGET_LOCK_DATA_BYTES, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "Size (in bytes) of available lock data this window can provided. If current buffered lock data is more than this value, the process will drop the upcoming operation data. Requires a positive calue.");
    rc = MPL_env2int("MPICH_CH3_RMA_TARGET_LOCK_DATA_BYTES", &(MPIR_CVAR_CH3_RMA_TARGET_LOCK_DATA_BYTES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_RMA_TARGET_LOCK_DATA_BYTES");
    rc = MPL_env2int("MPIR_PARAM_CH3_RMA_TARGET_LOCK_DATA_BYTES", &(MPIR_CVAR_CH3_RMA_TARGET_LOCK_DATA_BYTES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_RMA_TARGET_LOCK_DATA_BYTES");
    rc = MPL_env2int("MPIR_CVAR_CH3_RMA_TARGET_LOCK_DATA_BYTES", &(MPIR_CVAR_CH3_RMA_TARGET_LOCK_DATA_BYTES));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_RMA_TARGET_LOCK_DATA_BYTES");

    defaultval.d = 256;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_RMA_OP_WIN_POOL_SIZE, /* name */
        &MPIR_CVAR_CH3_RMA_OP_WIN_POOL_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "Size of the window-private RMA operations pool (in number of operations) that stores information about RMA operations that could not be issued immediately.  Requires a positive value.");
    rc = MPL_env2int("MPICH_CH3_RMA_OP_WIN_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_OP_WIN_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_RMA_OP_WIN_POOL_SIZE");
    rc = MPL_env2int("MPIR_PARAM_CH3_RMA_OP_WIN_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_OP_WIN_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_RMA_OP_WIN_POOL_SIZE");
    rc = MPL_env2int("MPIR_CVAR_CH3_RMA_OP_WIN_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_OP_WIN_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_RMA_OP_WIN_POOL_SIZE");

    defaultval.d = 16384;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_RMA_OP_GLOBAL_POOL_SIZE, /* name */
        &MPIR_CVAR_CH3_RMA_OP_GLOBAL_POOL_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "Size of the Global RMA operations pool (in number of operations) that stores information about RMA operations that could not be issued immediatly.  Requires a positive value.");
    rc = MPL_env2int("MPICH_CH3_RMA_OP_GLOBAL_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_OP_GLOBAL_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_RMA_OP_GLOBAL_POOL_SIZE");
    rc = MPL_env2int("MPIR_PARAM_CH3_RMA_OP_GLOBAL_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_OP_GLOBAL_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_RMA_OP_GLOBAL_POOL_SIZE");
    rc = MPL_env2int("MPIR_CVAR_CH3_RMA_OP_GLOBAL_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_OP_GLOBAL_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_RMA_OP_GLOBAL_POOL_SIZE");

    defaultval.d = 256;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_RMA_TARGET_WIN_POOL_SIZE, /* name */
        &MPIR_CVAR_CH3_RMA_TARGET_WIN_POOL_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "Size of the window-private RMA target pool (in number of targets) that stores information about RMA targets that could not be issued immediately.  Requires a positive value.");
    rc = MPL_env2int("MPICH_CH3_RMA_TARGET_WIN_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_TARGET_WIN_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_RMA_TARGET_WIN_POOL_SIZE");
    rc = MPL_env2int("MPIR_PARAM_CH3_RMA_TARGET_WIN_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_TARGET_WIN_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_RMA_TARGET_WIN_POOL_SIZE");
    rc = MPL_env2int("MPIR_CVAR_CH3_RMA_TARGET_WIN_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_TARGET_WIN_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_RMA_TARGET_WIN_POOL_SIZE");

    defaultval.d = 16384;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_RMA_TARGET_GLOBAL_POOL_SIZE, /* name */
        &MPIR_CVAR_CH3_RMA_TARGET_GLOBAL_POOL_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "Size of the Global RMA targets pool (in number of targets) that stores information about RMA targets that could not be issued immediatly.  Requires a positive value.");
    rc = MPL_env2int("MPICH_CH3_RMA_TARGET_GLOBAL_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_TARGET_GLOBAL_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_RMA_TARGET_GLOBAL_POOL_SIZE");
    rc = MPL_env2int("MPIR_PARAM_CH3_RMA_TARGET_GLOBAL_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_TARGET_GLOBAL_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_RMA_TARGET_GLOBAL_POOL_SIZE");
    rc = MPL_env2int("MPIR_CVAR_CH3_RMA_TARGET_GLOBAL_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_TARGET_GLOBAL_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_RMA_TARGET_GLOBAL_POOL_SIZE");

    defaultval.d = 256;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_RMA_TARGET_LOCK_ENTRY_WIN_POOL_SIZE, /* name */
        &MPIR_CVAR_CH3_RMA_TARGET_LOCK_ENTRY_WIN_POOL_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "Size of the window-private RMA lock entries pool (in number of lock entries) that stores information about RMA lock requests that could not be satisfied immediatly.  Requires a positive value.");
    rc = MPL_env2int("MPICH_CH3_RMA_TARGET_LOCK_ENTRY_WIN_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_TARGET_LOCK_ENTRY_WIN_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_RMA_TARGET_LOCK_ENTRY_WIN_POOL_SIZE");
    rc = MPL_env2int("MPIR_PARAM_CH3_RMA_TARGET_LOCK_ENTRY_WIN_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_TARGET_LOCK_ENTRY_WIN_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_RMA_TARGET_LOCK_ENTRY_WIN_POOL_SIZE");
    rc = MPL_env2int("MPIR_CVAR_CH3_RMA_TARGET_LOCK_ENTRY_WIN_POOL_SIZE", &(MPIR_CVAR_CH3_RMA_TARGET_LOCK_ENTRY_WIN_POOL_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_RMA_TARGET_LOCK_ENTRY_WIN_POOL_SIZE");

    defaultval.d = 65536;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_RMA_ACTIVE_REQ_THRESHOLD, /* name */
        &MPIR_CVAR_CH3_RMA_ACTIVE_REQ_THRESHOLD, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "Threshold of number of active requests to trigger blocking waiting in operation routines. When the value is negative, we never blockingly wait in operation routines. When the value is zero, we always trigger blocking waiting in operation routines to wait until no. of active requests becomes zero. When the value is positive, we do blocking waiting in operation routines to wait until no. of active requests being reduced to this value.");
    rc = MPL_env2int("MPICH_CH3_RMA_ACTIVE_REQ_THRESHOLD", &(MPIR_CVAR_CH3_RMA_ACTIVE_REQ_THRESHOLD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_RMA_ACTIVE_REQ_THRESHOLD");
    rc = MPL_env2int("MPIR_PARAM_CH3_RMA_ACTIVE_REQ_THRESHOLD", &(MPIR_CVAR_CH3_RMA_ACTIVE_REQ_THRESHOLD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_RMA_ACTIVE_REQ_THRESHOLD");
    rc = MPL_env2int("MPIR_CVAR_CH3_RMA_ACTIVE_REQ_THRESHOLD", &(MPIR_CVAR_CH3_RMA_ACTIVE_REQ_THRESHOLD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_RMA_ACTIVE_REQ_THRESHOLD");

    defaultval.d = 128;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_RMA_POKE_PROGRESS_REQ_THRESHOLD, /* name */
        &MPIR_CVAR_CH3_RMA_POKE_PROGRESS_REQ_THRESHOLD, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "Threshold at which the RMA implementation attempts to complete requests while completing RMA operations and while using the lazy synchonization approach.  Change this value if programs fail because they run out of requests or other internal resources");
    rc = MPL_env2int("MPICH_CH3_RMA_POKE_PROGRESS_REQ_THRESHOLD", &(MPIR_CVAR_CH3_RMA_POKE_PROGRESS_REQ_THRESHOLD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_RMA_POKE_PROGRESS_REQ_THRESHOLD");
    rc = MPL_env2int("MPIR_PARAM_CH3_RMA_POKE_PROGRESS_REQ_THRESHOLD", &(MPIR_CVAR_CH3_RMA_POKE_PROGRESS_REQ_THRESHOLD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_RMA_POKE_PROGRESS_REQ_THRESHOLD");
    rc = MPL_env2int("MPIR_CVAR_CH3_RMA_POKE_PROGRESS_REQ_THRESHOLD", &(MPIR_CVAR_CH3_RMA_POKE_PROGRESS_REQ_THRESHOLD));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_RMA_POKE_PROGRESS_REQ_THRESHOLD");

    defaultval.d = 0;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_ENABLE_HCOLL, /* name */
        &MPIR_CVAR_CH3_ENABLE_HCOLL, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "If true, enable HCOLL collectives.");
    rc = MPL_env2bool("MPICH_CH3_ENABLE_HCOLL", &(MPIR_CVAR_CH3_ENABLE_HCOLL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_ENABLE_HCOLL");
    rc = MPL_env2bool("MPIR_PARAM_CH3_ENABLE_HCOLL", &(MPIR_CVAR_CH3_ENABLE_HCOLL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_ENABLE_HCOLL");
    rc = MPL_env2bool("MPIR_CVAR_CH3_ENABLE_HCOLL", &(MPIR_CVAR_CH3_ENABLE_HCOLL));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_ENABLE_HCOLL");

    defaultval.d = 180;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_COMM_CONNECT_TIMEOUT, /* name */
        &MPIR_CVAR_CH3_COMM_CONNECT_TIMEOUT, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_GROUP_EQ,
        defaultval,
        "CH3", /* category */
        "The default time out period in seconds for a connection attempt to the server communicator where the named port exists but no pending accept. User can change the value for a specified connection through its info argument.");
    rc = MPL_env2int("MPICH_CH3_COMM_CONNECT_TIMEOUT", &(MPIR_CVAR_CH3_COMM_CONNECT_TIMEOUT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_COMM_CONNECT_TIMEOUT");
    rc = MPL_env2int("MPIR_PARAM_CH3_COMM_CONNECT_TIMEOUT", &(MPIR_CVAR_CH3_COMM_CONNECT_TIMEOUT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_COMM_CONNECT_TIMEOUT");
    rc = MPL_env2int("MPIR_CVAR_CH3_COMM_CONNECT_TIMEOUT", &(MPIR_CVAR_CH3_COMM_CONNECT_TIMEOUT));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_COMM_CONNECT_TIMEOUT");

    defaultval.d = 65536;
    MPIR_T_CVAR_REGISTER_STATIC(
        MPI_INT,
        MPIR_CVAR_CH3_RMA_OP_PIGGYBACK_LOCK_DATA_SIZE, /* name */
        &MPIR_CVAR_CH3_RMA_OP_PIGGYBACK_LOCK_DATA_SIZE, /* address */
        1, /* count */
        MPI_T_VERBOSITY_USER_BASIC,
        MPI_T_SCOPE_ALL_EQ,
        defaultval,
        "CH3", /* category */
        "Specify the threshold of data size of a RMA operation which can be piggybacked with a LOCK message. It is always a positive value and should not be smaller than MPIDI_RMA_IMMED_BYTES. If user sets it as a small value, for middle and large data size, we will lose performance because of always waiting for round-trip of LOCK synchronization; if user sets it as a large value, we need to consume more memory on target side to buffer this lock request when lock is not satisfied.");
    rc = MPL_env2int("MPICH_CH3_RMA_OP_PIGGYBACK_LOCK_DATA_SIZE", &(MPIR_CVAR_CH3_RMA_OP_PIGGYBACK_LOCK_DATA_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPICH_CH3_RMA_OP_PIGGYBACK_LOCK_DATA_SIZE");
    rc = MPL_env2int("MPIR_PARAM_CH3_RMA_OP_PIGGYBACK_LOCK_DATA_SIZE", &(MPIR_CVAR_CH3_RMA_OP_PIGGYBACK_LOCK_DATA_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_PARAM_CH3_RMA_OP_PIGGYBACK_LOCK_DATA_SIZE");
    rc = MPL_env2int("MPIR_CVAR_CH3_RMA_OP_PIGGYBACK_LOCK_DATA_SIZE", &(MPIR_CVAR_CH3_RMA_OP_PIGGYBACK_LOCK_DATA_SIZE));
    MPIR_ERR_CHKANDJUMP1((-1 == rc),mpi_errno,MPI_ERR_OTHER,"**envvarparse","**envvarparse %s","MPIR_CVAR_CH3_RMA_OP_PIGGYBACK_LOCK_DATA_SIZE");

fn_exit:
    return mpi_errno;
fn_fail:
    goto fn_exit;
}

int MPIR_T_cvar_finalize(void)
{
    int mpi_errno = MPI_SUCCESS;

    if (MPIR_CVAR_EXSCAN_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_EXSCAN_INTRA_ALGORITHM);
        MPIR_CVAR_EXSCAN_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM);
        MPIR_CVAR_IREDUCE_SCATTER_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM);
        MPIR_CVAR_IREDUCE_SCATTER_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM);
        MPIR_CVAR_IALLTOALLW_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM);
        MPIR_CVAR_IALLTOALLW_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM);
        MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM);
        MPIR_CVAR_NEIGHBOR_ALLTOALLW_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM);
        MPIR_CVAR_IALLTOALLV_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM);
        MPIR_CVAR_IALLTOALLV_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM);
        MPIR_CVAR_ALLGATHERV_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM);
        MPIR_CVAR_ALLGATHERV_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM);
        MPIR_CVAR_ALLREDUCE_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM);
        MPIR_CVAR_ALLREDUCE_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IGATHER_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IGATHER_INTRA_ALGORITHM);
        MPIR_CVAR_IGATHER_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IGATHER_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IGATHER_INTER_ALGORITHM);
        MPIR_CVAR_IGATHER_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM);
        MPIR_CVAR_NEIGHBOR_ALLTOALL_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM);
        MPIR_CVAR_NEIGHBOR_ALLTOALL_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM);
        MPIR_CVAR_IALLTOALL_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IALLTOALL_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IALLTOALL_INTER_ALGORITHM);
        MPIR_CVAR_IALLTOALL_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_SCATTER_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_SCATTER_INTRA_ALGORITHM);
        MPIR_CVAR_SCATTER_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_SCATTER_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_SCATTER_INTER_ALGORITHM);
        MPIR_CVAR_SCATTER_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM);
        MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM);
        MPIR_CVAR_NEIGHBOR_ALLGATHERV_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IREDUCE_TREE_TYPE != NULL) {
        MPL_free(MPIR_CVAR_IREDUCE_TREE_TYPE);
        MPIR_CVAR_IREDUCE_TREE_TYPE = NULL;
    }

    if (MPIR_CVAR_IREDUCE_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IREDUCE_INTRA_ALGORITHM);
        MPIR_CVAR_IREDUCE_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IREDUCE_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IREDUCE_INTER_ALGORITHM);
        MPIR_CVAR_IREDUCE_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM);
        MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM);
        MPIR_CVAR_REDUCE_SCATTER_BLOCK_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_GATHERV_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_GATHERV_INTRA_ALGORITHM);
        MPIR_CVAR_GATHERV_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_GATHERV_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_GATHERV_INTER_ALGORITHM);
        MPIR_CVAR_GATHERV_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ISCATTER_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ISCATTER_INTRA_ALGORITHM);
        MPIR_CVAR_ISCATTER_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ISCATTER_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ISCATTER_INTER_ALGORITHM);
        MPIR_CVAR_ISCATTER_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM);
        MPIR_CVAR_NEIGHBOR_ALLGATHER_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM);
        MPIR_CVAR_NEIGHBOR_ALLGATHER_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM);
        MPIR_CVAR_ALLGATHER_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ALLGATHER_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ALLGATHER_INTER_ALGORITHM);
        MPIR_CVAR_ALLGATHER_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM);
        MPIR_CVAR_ALLTOALLV_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM);
        MPIR_CVAR_ALLTOALLV_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM);
        MPIR_CVAR_ALLTOALL_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ALLTOALL_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ALLTOALL_INTER_ALGORITHM);
        MPIR_CVAR_ALLTOALL_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM);
        MPIR_CVAR_IALLREDUCE_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM);
        MPIR_CVAR_IALLREDUCE_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM);
        MPIR_CVAR_IEXSCAN_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM);
        MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM);
        MPIR_CVAR_INEIGHBOR_ALLTOALLW_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM);
        MPIR_CVAR_REDUCE_SCATTER_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM);
        MPIR_CVAR_REDUCE_SCATTER_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM);
        MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM);
        MPIR_CVAR_INEIGHBOR_ALLTOALLV_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM);
        MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM);
        MPIR_CVAR_NEIGHBOR_ALLTOALLV_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IBARRIER_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IBARRIER_INTRA_ALGORITHM);
        MPIR_CVAR_IBARRIER_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IBARRIER_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IBARRIER_INTER_ALGORITHM);
        MPIR_CVAR_IBARRIER_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_BCAST_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_BCAST_INTRA_ALGORITHM);
        MPIR_CVAR_BCAST_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_BCAST_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_BCAST_INTER_ALGORITHM);
        MPIR_CVAR_BCAST_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IGATHERV_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IGATHERV_INTRA_ALGORITHM);
        MPIR_CVAR_IGATHERV_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IGATHERV_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IGATHERV_INTER_ALGORITHM);
        MPIR_CVAR_IGATHERV_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM);
        MPIR_CVAR_IALLGATHERV_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM);
        MPIR_CVAR_IALLGATHERV_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ISCAN_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ISCAN_INTRA_ALGORITHM);
        MPIR_CVAR_ISCAN_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_SCAN_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_SCAN_INTRA_ALGORITHM);
        MPIR_CVAR_SCAN_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM);
        MPIR_CVAR_INEIGHBOR_ALLTOALL_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM);
        MPIR_CVAR_INEIGHBOR_ALLTOALL_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_REDUCE_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_REDUCE_INTRA_ALGORITHM);
        MPIR_CVAR_REDUCE_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_REDUCE_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_REDUCE_INTER_ALGORITHM);
        MPIR_CVAR_REDUCE_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM);
        MPIR_CVAR_ALLTOALLW_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM);
        MPIR_CVAR_ALLTOALLW_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_BARRIER_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_BARRIER_INTRA_ALGORITHM);
        MPIR_CVAR_BARRIER_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_BARRIER_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_BARRIER_INTER_ALGORITHM);
        MPIR_CVAR_BARRIER_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM);
        MPIR_CVAR_ISCATTERV_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_ISCATTERV_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_ISCATTERV_INTER_ALGORITHM);
        MPIR_CVAR_ISCATTERV_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM);
        MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM);
        MPIR_CVAR_INEIGHBOR_ALLGATHERV_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_SCATTERV_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_SCATTERV_INTRA_ALGORITHM);
        MPIR_CVAR_SCATTERV_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_SCATTERV_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_SCATTERV_INTER_ALGORITHM);
        MPIR_CVAR_SCATTERV_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_GATHER_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_GATHER_INTRA_ALGORITHM);
        MPIR_CVAR_GATHER_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_GATHER_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_GATHER_INTER_ALGORITHM);
        MPIR_CVAR_GATHER_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM);
        MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM);
        MPIR_CVAR_IREDUCE_SCATTER_BLOCK_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM);
        MPIR_CVAR_IALLGATHER_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IALLGATHER_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IALLGATHER_INTER_ALGORITHM);
        MPIR_CVAR_IALLGATHER_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IBCAST_TREE_TYPE != NULL) {
        MPL_free(MPIR_CVAR_IBCAST_TREE_TYPE);
        MPIR_CVAR_IBCAST_TREE_TYPE = NULL;
    }

    if (MPIR_CVAR_IBCAST_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IBCAST_INTRA_ALGORITHM);
        MPIR_CVAR_IBCAST_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_IBCAST_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_IBCAST_INTER_ALGORITHM);
        MPIR_CVAR_IBCAST_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM);
        MPIR_CVAR_INEIGHBOR_ALLGATHER_INTRA_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM != NULL) {
        MPL_free(MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM);
        MPIR_CVAR_INEIGHBOR_ALLGATHER_INTER_ALGORITHM = NULL;
    }

    if (MPIR_CVAR_NETLOC_NODE_FILE != NULL) {
        MPL_free(MPIR_CVAR_NETLOC_NODE_FILE);
        MPIR_CVAR_NETLOC_NODE_FILE = NULL;
    }

    if (MPIR_CVAR_DEFAULT_THREAD_LEVEL != NULL) {
        MPL_free(MPIR_CVAR_DEFAULT_THREAD_LEVEL);
        MPIR_CVAR_DEFAULT_THREAD_LEVEL = NULL;
    }

    if (MPIR_CVAR_NAMESERV_FILE_PUBDIR != NULL) {
        MPL_free(MPIR_CVAR_NAMESERV_FILE_PUBDIR);
        MPIR_CVAR_NAMESERV_FILE_PUBDIR = NULL;
    }

    if (MPIR_CVAR_CH4_NETMOD != NULL) {
        MPL_free(MPIR_CVAR_CH4_NETMOD);
        MPIR_CVAR_CH4_NETMOD = NULL;
    }

    if (MPIR_CVAR_CH4_SHM != NULL) {
        MPL_free(MPIR_CVAR_CH4_SHM);
        MPIR_CVAR_CH4_SHM = NULL;
    }

    if (MPIR_CVAR_CH4_MT_MODEL != NULL) {
        MPL_free(MPIR_CVAR_CH4_MT_MODEL);
        MPIR_CVAR_CH4_MT_MODEL = NULL;
    }

    if (MPIR_CVAR_OFI_USE_PROVIDER != NULL) {
        MPL_free(MPIR_CVAR_OFI_USE_PROVIDER);
        MPIR_CVAR_OFI_USE_PROVIDER = NULL;
    }

    if (MPIR_CVAR_CH3_INTERFACE_HOSTNAME != NULL) {
        MPL_free(MPIR_CVAR_CH3_INTERFACE_HOSTNAME);
        MPIR_CVAR_CH3_INTERFACE_HOSTNAME = NULL;
    }

    if (MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE != NULL) {
        MPL_free(MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE);
        MPIR_CVAR_NEMESIS_TCP_NETWORK_IFACE = NULL;
    }

    if (MPIR_CVAR_NEMESIS_NETMOD != NULL) {
        MPL_free(MPIR_CVAR_NEMESIS_NETMOD);
        MPIR_CVAR_NEMESIS_NETMOD = NULL;
    }

    return mpi_errno;
}

